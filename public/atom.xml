<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[classicemi's blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://classicemi.github.io/"/>
  <updated>2014-10-04T15:59:37.770Z</updated>
  <id>http://classicemi.github.io/</id>
  
  <author>
    <name><![CDATA[classicemi]]></name>
    <email><![CDATA[wushuang1227@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[消失的属性]]></title>
    <link href="http://classicemi.github.io/2014/10/04/missing-properties-in-console/"/>
    <id>http://classicemi.github.io/2014/10/04/missing-properties-in-console/</id>
    <published>2014-10-04T14:29:28.000Z</published>
    <updated>2014-10-04T15:42:15.000Z</updated>
    <content type="html"><![CDATA[<p>最近在开发组件的过程中，需要随时监控整个组件对象的构建，包括对象上的属性方法的变更，以及原型链的变化。本来，在测试代码中加一个<code>console.log</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> d = <span class="keyword">new</span> dialog({
    ...
});
console.log(<span class="string">'final object'</span>, d);
d.show();
</pre></td></tr></table></figure>

<p>就可以观察最终生成的组件对象是否符合我的预期，也没出过什么问题，也没理由会出现什么问题，直到调试过程中出现了这样的情况：</p>
<a id="more"></a>

<p>组件的配置需要将用户传入的配置属性和默认属性进行合并，然后需要对组件对象中的一个属性布尔值进行判断后改写组件的另一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">this</span>.maskOpacity = <span class="keyword">this</span>.modal ? <span class="keyword">this</span>.maskOpacity : <span class="number">0</span>;
</pre></td></tr></table></figure>

<p>第一眼看上去代码似乎没有问题(实际上有问题)，但是运行时和预期行为不一致，<code>this.modal</code>的判定始终为<code>false</code>。那么我就很顺手地打上一句<code>console.log(this)</code>来检查对象的属性，当调整传入的配置对象时，生成对象上的<code>this.modal</code>属性应该会随之变化，检查控制台输出结果，<code>this.modal</code>的值确实是会根据参数不同而变化的。这就奇怪了，试着打断点调试，结果就不一样了，<code>this.modal</code>的值在执行判断时显示为<code>undefined</code>。同样的事情在Chrome和FF中都发生了。</p>
<p>这个<code>modal</code>属性神秘消失了。</p>
<p>问题一分为二，一个是代码本身的逻辑问题，经过进一步调试，在执行到这句判断的时候，配置对象中的<code>modal</code>属性值还未写入<code>this</code>，所以<code>this.modal</code>值为<code>undefined</code>的现象是正常的，通过修改<code>this.modal</code>为<code>opt.modal</code>比较轻易就解决了。第二个问题却是在调试过程中遇到的，<code>console.log</code>出的<code>this</code>为何能查找到本不应存在的<code>modal</code>属性，导致误导了我的思路。借助于万能的StackOverflow，最后总算是找到了原因。</p>
<p>这段组件的代码逻辑是比较复杂的，其中的<code>this.modal</code>属性，在上文执行判断的语句处，确实应该<code>undefined</code>，但是在后面的代码中，有这样一段赋值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">this</span>.modal = opt.modal = <span class="literal">true</span>;
</pre></td></tr></table></figure>

<p>这段赋值直接改写了<code>this.modal</code>，可为何后文的赋值会影响到前文的输出呢？其中的原因在于，当<code>console.log(this)</code>输出时，<code>this</code>对象在控制台中的显示为折叠状态，如图：<br><img src="/img/missing-properties-in-console/fold-this.jpg" alt=""><br>为了查看对象中具体的属性信息，就必须用鼠标点一下展开，这个时候，JS早就执行完毕了，<code>this.modal</code>的值也已改写，在展开<code>this</code>对象的时刻，<code>this</code>中的属性显示结果实际上是<code>this</code>对象的最终形态，那么这种输出上的“延迟”是延迟到所有JS执行结束还是仅局限于<code>console</code>语句所在函数作用域内呢？我们可以写段代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> foo = {};
<span class="function"><span class="keyword">function</span> <span class="title">addProperty</span><span class="params">()</span> {</span>
    foo.test1 = <span class="string">'test1'</span>;
    foo.test2 = <span class="string">'test2'</span>;
    foo.test3 = <span class="string">'test3'</span>;
    foo.test4 = <span class="string">'test4'</span>;
    foo.test5 = <span class="string">'test5'</span>;
    foo.test6 = <span class="string">'test6'</span>;
    foo.test7 = <span class="string">'test7'</span>;
    foo.test8 = <span class="string">'test8'</span>;
    foo.test9 = <span class="string">'test9'</span>;
    console.log(foo);
    foo.bar = <span class="string">'bar'</span>;
}
addProperty();
foo.baz = <span class="string">'baz'</span>;
foo = <span class="literal">null</span>;
console.log(foo);
</pre></td></tr></table></figure>

<p>代码写得很挫，纯粹是为了测试而写了。在这里我还在最后加了一个对<code>null</code>的指向来销毁对象（严格来说还应该delete掉对象的所有属性，这里省略），控制台中的输出如下：<br><img src="/img/missing-properties-in-console/expand-test.jpg" alt=""><br>可见，控制台中输出的“延迟范围”是整个脚本代码的范围，不局限于某个函数作用域，同时还不受赋值为<code>null</code>的影响，当然，在<code>foo = null;</code>之后的<code>console</code>的输出就确实为<code>null</code>了。</p>
<p>同时，触发这种“延迟”现象还有一个必要条件，那就是输出对象的属性要足够多，使得控制台会先将对象内容折叠起来，给用户点击展开的机会，如果属性过少，两行就显示完了，也就看不到这个bug了。</p>
<p>在各种条件的巧合作用下发现了这样一个现象，在今后的开发过程中要加以注意，不要受到误导，甚至于利用这种特性为开发提供便捷。</p>
]]></content>
    <summary type="html"><![CDATA[<p>最近在开发组件的过程中，需要随时监控整个组件对象的构建，包括对象上的属性方法的变更，以及原型链的变化。本来，在测试代码中加一个<code>console.log</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> d = <span class="keyword">new</span> dialog({
    ...
});
console.log(<span class="string">'final object'</span>, d);
d.show();
</pre></td></tr></table></figure>

<p>就可以观察最终生成的组件对象是否符合我的预期，也没出过什么问题，也没理由会出现什么问题，直到调试过程中出现了这样的情况：</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[部分浏览器检测方法]]></title>
    <link href="http://classicemi.github.io/2014/05/16/browser-detect/"/>
    <id>http://classicemi.github.io/2014/05/16/browser-detect/</id>
    <published>2014-05-16T12:07:28.000Z</published>
    <updated>2014-05-18T02:58:03.000Z</updated>
    <content type="html"><![CDATA[<p>检测方法均摘自司徒正美所著《JavaScript框架设计》一书，同样内容在其博客中亦有记载。我在原内容基础上对判断方法的原理加上了注释，便于理解记忆。</p>
<a id="more"></a>

<h2 id="jQuery解决方案">jQuery解决方案</h2>
<p>分析<code>window.navigator.userAgent</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> ua = window.navigator.userAgent;

<span class="comment">// 亲测可能会存在问题</span>
<span class="keyword">var</span> match = <span class="regexp">/(Chrome)[ \/]([\w.]+)/</span>.exec(ua) ||
            <span class="regexp">/(Webkit)[ \/]([\w.]+)/</span>.exec(ua) ||
            <span class="regexp">/(OPR)(?:.*version|)[ \/]([\w.]+)/</span>.exec(ua) ||
            <span class="regexp">/(MSIE) ([\w.]+)/</span>.exec(ua) ||
            ua.indexOf(<span class="string">'compatible'</span>) &lt; <span class="number">0</span> && <span class="regexp">/(Mozilla)(?:.*?rv:([\w.]+)|)/</span>.exec(ua) || [];
</pre></td></tr></table></figure>

<p>匹配的分句会返回如图所示的数组，包含浏览器型号与版本号：<br><img src="/img/browser-detect-firefox.jpg" alt=""></p>
<p>移动平台的检测：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> platform_match = <span class="regexp">/(ipad)/</span>.exec(ua) ||
                     <span class="regexp">/(iphone)/</span>.exec(ua) ||
                     <span class="regexp">/(android)/</span>.exec(ua) || [];
</pre></td></tr></table></figure>

<p>这个没有测。</p>
<p>返回一个结果对象就行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">return</span> {
  browser: match[<span class="number">1</span>],
  version: match[<span class="number">2</span>],
  platform: platform_match[<span class="number">0</span>] || <span class="string">''</span>
}
</pre></td></tr></table></figure>

<p>一般浏览器的信息这样检测就基本能满足了，对于某些特定功能，建议用能力检测而不是浏览器检测。</p>
<h2 id="通过能力检测判断浏览器">通过能力检测判断浏览器</h2>
<p>我认为这是比检测<code>navigator.userAgent</code>更好的方法。这样可以检测出更多浏览器的版本信息，例如判断IE浏览器的版本，非常有用：<br><strong>IE</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>ie = !!document.recalc;
ie = !!window.VBArray;
ie = !!window.ActiveXObject;
ie = !!document.createPopup;
</pre></td></tr></table></figure>

<p>以上为通过能力检测判断是否为IE浏览器的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie = <span class="comment">/*@cc_on!@*/</span>!<span class="number">1</span>;
</pre></td></tr></table></figure>

<p>这是IE中特有的条件编译（conditional compilation）注释，可以写在脚本的开头。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie = document.expando; <span class="comment">// 常用document.all有bug，在firefox和opera的古老版本中也存在</span>
</pre></td></tr></table></figure>

<p>IE9+中似乎无效。</p>
<p><strong>特定版本的IE</strong><br><em>IE678</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = !+<span class="string">"\v1"</span>;
</pre></td></tr></table></figure>

<p>IE678不能吧<code>\v</code>解释为垂直符，只能表现为<code>&quot;v&quot;</code>字符串，<code>+</code>号转换为数字失败，转换为NaN，取反得<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = !-[<span class="number">1</span>, ];
</pre></td></tr></table></figure>

<p>IE678中调用<code>toString()</code>方法得到<code>&quot;1,&quot;</code>，取负返回NaN，再取反得<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = <span class="string">'\v'</span> == <span class="string">'v'</span>;
</pre></td></tr></table></figure>

<p>这个原理已经说了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = (<span class="string">'a~b'</span>.split(<span class="regexp">/(~)/</span>))[<span class="number">1</span>] == <span class="string">'b'</span>;
</pre></td></tr></table></figure>

<p>IE678版本<code>split</code>方法返回的是<code>[&#39;a&#39;, &#39;~&#39;, &#39;b&#39;]</code>数组，IE9+版本返回<code>[&#39;a&#39;, &#39;b&#39;]</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = <span class="number">0.9</span>.toFixed(<span class="number">0</span>) == <span class="string">'0'</span>;
</pre></td></tr></table></figure>

<p>此方法在Win8平台下通过IE10开发者工具模拟IE8-版本发现无效，返回值都为<code>&#39;1&#39;</code>，不知原生版本是否有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>ie678 = <span class="regexp">/\w/</span>.test(<span class="string">'\u0130'</span>);
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<p>检测方法均摘自司徒正美所著《JavaScript框架设计》一书，同样内容在其博客中亦有记载。我在原内容基础上对判断方法的原理加上了注释，便于理解记忆。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="兼容性" scheme="http://classicemi.github.io/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(七)——适配器模式]]></title>
    <link href="http://classicemi.github.io/2014/05/12/javascript-pattern-07/"/>
    <id>http://classicemi.github.io/2014/05/12/javascript-pattern-07/</id>
    <published>2014-05-12T12:14:28.000Z</published>
    <updated>2014-05-12T14:14:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="与门面模式的联系">与门面模式的联系</h2>
<p>本文要说的适配器模式和上一篇门面模式在思想上有相似之处，所以放在一起说。它们都对类的接口进行了一些改变。门面模式是把相似的或是完成相关任务的接口进行组织，提供给用户一个更加简单易用，更适用于某种业务的接口。而适配器模式是要把一个接口转换为另一个接口，它不对接口的功能进行干涉，它不会简化接口，而是将接口变为更丰富且兼容的接口。</p>
<p>简而言之，门面模式是让本来就可以用的接口变得更好用。而适配器是让不合适的接口变得合适。</p>
<a id="more"></a>

<h2 id="适配器的概念">适配器的概念</h2>
<p>适配器的思想用线框图来表示就是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre> +------+          +------+
 |  某  |interface1|  适  | interface2
 |  个--|----------|--配--|------------→
 |  类  |          |  器  |
 +------+          +------+
</pre></td></tr></table></figure>

<p>这个框图能让人想起什么？我想到了这个：<br><img src="/img/adapter.jpg" alt=""><br>将一个不能直接使用的耳机接头进行转换，成为可以使用的样子。</p>
<p>假设一个类的方法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>orange.showInfo = <span class="function"><span class="keyword">function</span><span class="params">(name, color, weight)</span> {</span>
  console.log(name + <span class="string">' is '</span> + color + <span class="string">' and its weight is '</span> + weight);
};
</pre></td></tr></table></figure>

<p>而我们现有的对象都是这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> o = {
  name: <span class="string">'classicemi'</span>,
  color: <span class="string">'orange'</span>,
  weight: <span class="string">'300g'</span>
}
</pre></td></tr></table></figure>

<p>我们当然可以这样使用接口：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>orange.showInfo(o.name, o.color, o.weight);
</pre></td></tr></table></figure>

<p>同样，我们也可以：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">adaptedShowInfo</span><span class="params">(o)</span> {</span>
  orange.showInfo(o.name, o.color, o.weight);
}

<span class="comment">// 通过适配过的接口进行调用</span>
adaptedShowInfo(o);
</pre></td></tr></table></figure>

<p>这样，简化了接口的调用过程，对接口进行了一定程度的改造。</p>
<h2 id="jQuery中的适配器">jQuery中的适配器</h2>
<p>上面提到的适配器写法只是表现了适配器是一个什么样的东西，但实际项目中不会出现这样的代码。我们以jQuery中的一个API为例，说说实际应用中的适配器模式的使用方法。</p>
<p>在jQuery样式相关的API中，最方便使用的就是<code>css()</code>了，这个接口是把<code>set</code>和<code>get</code>的功能合二为一了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// 既可以像这样调用，取得opacity值</span>
$(<span class="string">'.elem'</span>).css(<span class="string">'opacity'</span>);

<span class="comment">// 也可以像这样，设置opacity值</span>
$(<span class="string">'.elem'</span>).css({<span class="string">'opacity'</span>: <span class="string">'0.9'</span>});
</pre></td></tr></table></figure>

<p>这是怎么实现的呢，在jQuery核心代码中，与set/get opacity相关的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="code"><pre>jQuery.cssHooks.opacity = {
  get: <span class="function"><span class="keyword">function</span><span class="params">( elem, computed )</span> {</span>
    <span class="comment">// IE uses filters for opacity</span>
    <span class="keyword">return</span> ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || <span class="string">""</span> ) ?
      ( <span class="number">0.01</span> * <span class="built_in">parseFloat</span>( <span class="built_in">RegExp</span>.$<span class="number">1</span> ) ) + <span class="string">""</span> :
      computed ? <span class="string">"1"</span> : <span class="string">""</span>;
  },

  set: <span class="function"><span class="keyword">function</span><span class="params">( elem, value )</span> {</span>
    <span class="keyword">var</span> style = elem.style,
      currentStyle = elem.currentStyle,
      opacity = jQuery.isNumeric( value ) ? <span class="string">"alpha(opacity="</span> + value * <span class="number">100</span> + <span class="string">")"</span> : <span class="string">""</span>,
      filter = currentStyle && currentStyle.filter || style.filter || <span class="string">""</span>;

    <span class="comment">// IE has trouble with opacity if it does not have layout</span>
    <span class="comment">// Force it by setting the zoom level</span>
    style.zoom = <span class="number">1</span>;

    <span class="comment">// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652</span>
    <span class="comment">// if value === "", then remove inline opacity #12685</span>
    <span class="keyword">if</span> ( ( value &gt;= <span class="number">1</span> || value === <span class="string">""</span> ) &&
        jQuery.trim( filter.replace( ralpha, <span class="string">""</span> ) ) === <span class="string">""</span> &&
        style.removeAttribute ) {

      <span class="comment">// Setting style.filter to null, "" & " " still leave "filter:" in the cssText</span>
      <span class="comment">// if "filter:" is present at all, clearType is disabled, we want to avoid this</span>
      <span class="comment">// style.removeAttribute is IE Only, but so apparently is this code path...</span>
      style.removeAttribute( <span class="string">"filter"</span> );

      <span class="comment">// if there is no filter style applied in a css rule or unset inline opacity, we are done</span>
      <span class="keyword">if</span> ( value === <span class="string">""</span> || currentStyle && !currentStyle.filter ) {
        <span class="keyword">return</span>;
      }
    }

    <span class="comment">// otherwise, set new filter values</span>
    style.filter = ralpha.test( filter ) ?
      filter.replace( ralpha, opacity ) :
      filter + <span class="string">" "</span> + opacity;
  }
};
</pre></td></tr></table></figure>

<p>通过对传入参数的适配，实现不同的功能。因为不看参数的话，调用的方式是完全一样的。那么从参数下手，通过校验参数的形式，确定用户要实现的功能。</p>
<h2 id="适配器模式的适用场景">适配器模式的适用场景</h2>
<p>适配器不会去改变实现层，那不属于它的职责范围，它干涉了抽象的过程。外部接口的适配能够让同一个方法适用于多种系统。</p>
<p>如果内部的实现出现了问题，需要动手术解决的话，那就不应该使用适配器了，因为那只是治标不治本的方法，反而会增加代码的复杂度。对实现进行全面优化的带来的是真正的改善。而如果实现层的问题不大，要解决一部分适配问题的话，适配器模式就是很好的选择了。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="与门面模式的联系">与门面模式的联系</h2>
<p>本文要说的适配器模式和上一篇门面模式在思想上有相似之处，所以放在一起说。它们都对类的接口进行了一些改变。门面模式是把相似的或是完成相关任务的接口进行组织，提供给用户一个更加简单易用，更适用于某种业务的接口。而适配器模式是要把一个接口转换为另一个接口，它不对接口的功能进行干涉，它不会简化接口，而是将接口变为更丰富且兼容的接口。</p>
<p>简而言之，门面模式是让本来就可以用的接口变得更好用。而适配器是让不合适的接口变得合适。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(六)——门面模式]]></title>
    <link href="http://classicemi.github.io/2014/05/11/javascript-pattern-06/"/>
    <id>http://classicemi.github.io/2014/05/11/javascript-pattern-06/</id>
    <published>2014-05-11T04:14:28.000Z</published>
    <updated>2014-05-11T14:17:11.000Z</updated>
    <content type="html"><![CDATA[<p>门面模式是什么，与其我去用笨拙的语言去解释，不如看下面这张图，曾经在网上很火的一张图片，说的是一位儿子为他的爸妈设置的电脑桌面。</p>
<a id="more"></a>

<p><img src="/img/门面_爸妈桌面.jpg" alt=""></p>
<p>有了这些起好名字的快捷方式，身为电脑盲的爸妈就不需要去了解何为浏览器，何为播放器了，照着指示点就是了。这些快捷方式相当于在用户和计算机程序之间架起了一座桥梁，不需要每个用户都像电影里的黑客一样敲着一行行的代码才能使用计算机的功能。这就是门面模式的意义——把复杂的功能（接口）经过包装，让用户（开发者）能间接地，比较简单地去使用（调用）它们，简化使用（开发）的难度。</p>
<h2 id="简单的门面模式实例——事件绑定函数">简单的门面模式实例——事件绑定函数</h2>
<p>门面模式的作用是将复杂的接口进行包装，变成一个便于使用的接口。在很多的JavaScript库中都能找到门面模式的应用，例如jQuery，我们在用jQuery进行事件绑定的时候，简单的调用<code>bind()</code>，<code>on()</code>等方法就可以了，并不用对不同浏览器的兼容性问题进行处理，兼容性的处理在jQuery内部已经完成，就是通过门面的思想。</p>
<p>我们就以事件绑定为例，来展现一下门面模式是什么：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">// 实现一个通用的，跨多种浏览器的时间绑定函数</span>
<span class="function"><span class="keyword">function</span> <span class="title">addEvent</span><span class="params">(el, type, fn)</span> {</span>
  <span class="keyword">if</span> (window.addEventListener) {
    el.addEventListener(type, fn, <span class="literal">false</span>);
  } <span class="keyword">else</span> <span class="keyword">if</span> (window.attachEvent) {
    el.attachEvent(<span class="string">'on'</span> + type, fn);
  } <span class="keyword">else</span> {
    el[<span class="string">'on'</span> + type] = fn;
  }
}
</pre></td></tr></table></figure>

<p>通过<strong>能力检测</strong>，对浏览器支持的API进行判断，自动调用有效的事件绑定API来绑定时间。开发者在绑定时间的时候，就不需要写冗长的判断代码，直接专注于业务就好，这是门面模式带来的最直接的便利。</p>
<p>这里门面模式的作用是处理浏览器的<strong>兼容性</strong>，门面模式的另一个作用是对多个函数进行<strong>组合</strong>管理。</p>
<p>还是以事件相关API为例，事件绑定中还有两个常用的API分别是<code>event.stopPropagation()</code>和<code>event.preventDefault()</code>。这两个API在IE浏览器中是不兼容的，在IE中它们分别对应的是<code>event.cancelBubble = true</code>和<code>event.returnValue = false</code>。通过门面模式我们的目标是：<br>没有蛀牙~~~<br>以及：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>+---------------+      +------------+      +--------------+      +-----------+
|stopPropagation|      |cancelBubble|      |preventDefault|      |returnValue|
+---------------+      +------------+      +--------------+      +-----------+
        |                    |                    |                        |
        +--------------------+                    +------------------------+
                   ↓                                          ↓
           +---------------+                           +--------------+
           |stopPropagation|                           |preventDefault|
           +---------------+                           +--------------+
                   |                wrapped in                 |
                   +-------------------------------------------+
                                        ↓
                          +-----------------------------+
                          |          ╭ stopPropagation |
                          | stopEvent                   |
                          |          ╰ preventDefault  |
                          +-----------------------------+
</pre></td></tr></table></figure>

<p>通过代码事件就是这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> eventUtil = {
  stopPropagation: <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> {</span>
    <span class="keyword">if</span> (ev.stopPropagation) {
      ev.stopPropagation();
    } <span class="keyword">else</span> {
      ev.cancelBubble = <span class="literal">true</span>;
    }
  },
  preventDefault: <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> {</span>
    <span class="keyword">if</span> (ev.preventDefault) {
      ev.preventDefault();
    } <span class="keyword">else</span> {
      ev.returnValue = <span class="literal">false</span>;
    }
  },
  stopEvent: <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> {</span>
    eventUtil.stopPropagation(ev);
    eventUtil.preventDefault(ev);
  }
}
</pre></td></tr></table></figure>

<p>这样，在事件绑定函数中，如果需要取消冒泡和默认事件的话，直接调用<code>eventUtil.stopEvent(ev)</code>即可，该方法将所需的子方法进行了包装，也处理了兼容性问题。</p>
<h2 id="门面模式在模块中的应用">门面模式在模块中的应用</h2>
<p>结合以前说过的对象创建模式，门面模式可以应用在模块之中，通过对私用方法的包装提供简化的公用方法，开发者维护模块时只需修改私用方法就可以调整公用方法的实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="keyword">var</span> orange = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// 私用方法包装对象</span>
  <span class="keyword">var</span> _privateMethod = {
    orangeValue: <span class="number">10</span>,
    getValue: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      console.log(<span class="keyword">this</span>.orangeValue);
    },
    setValue: <span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
      <span class="keyword">this</span>.orangeValue = value;
    }
  }

  <span class="comment">// 返回公用方法</span>
  <span class="keyword">return</span> {
    setOrangeValue: <span class="function"><span class="keyword">function</span><span class="params">(value)</span> {</span>
      _privateMethod.setValue(value);
      _privateMethod.getValue();
    }
  }
})();
</pre></td></tr></table></figure>

<p>门面模式能提供编写方式的灵活性，通过对底层子方法的封装，既简化了代码又降低了对底层系统的耦合。在大型系统工具库的使用中有重要的意义。但在实际项目中还是要考虑代码量的<strong>轻便性</strong>，如果业务只需要一些小粒度的方法的话，就没有必要使用包装了很多无用方法的门面函数了，这需要开发者灵活判断。</p>
]]></content>
    <summary type="html"><![CDATA[<p>门面模式是什么，与其我去用笨拙的语言去解释，不如看下面这张图，曾经在网上很火的一张图片，说的是一位儿子为他的爸妈设置的电脑桌面。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[浅谈 JavaScript 模块化编程]]></title>
    <link href="http://classicemi.github.io/2014/05/04/javascript-module-programming/"/>
    <id>http://classicemi.github.io/2014/05/04/javascript-module-programming/</id>
    <published>2014-05-04T04:14:28.000Z</published>
    <updated>2014-05-04T13:37:04.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript本身不是一种模块化语言，设计者在创造JavaScript之初应该也没有想到这么一个脚本语言的作用领域会越来越大。以前一个页面的JS代码再多也不会多到哪儿去，而现在随着越来越多的JavaScript库和框架的出现，Single-page App的流行以及Node.js的迅猛发展，如果我们还不对自己的JS代码进行一些模块化的组织的话，开发过程会越来越困难，运行性能也会越来越低。因此，了解JS模块化编程是非常重要的。</p>
<a id="more"></a>

<h2 id="简单的模块">简单的模块</h2>
<p>什么是模块？我认为将不同功能的函数放在一起，组成一个能实现某种或某些特定功能的整体就是一个模块，因此这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span> {</span>
  <span class="keyword">return</span> a + b;
}

<span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b)</span> {</span>
  <span class="keyword">return</span> a / b;
}
</pre></td></tr></table></figure>

<p>如此简单的两个函数就可以组成一个模块，这个模块可以进行一些数学运算。</p>
<p>当然没有人会这么写模块。仅仅是从“型”上来看，两个函数分散在全局环境中，这也看不出模块的特点。模块存在于全局变量中，应该提供一个命名空间，成为模块内容的入口。那么我们可以将函数包裹在一个对象中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> math = {
  add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a + b;
  },
  divide: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a / b;
  }
}
</pre></td></tr></table></figure>

<p>这样看起来似乎有模块的“型”了。但是这样还不完善，<code>math</code>中的所有成员都是对外暴露的，如果其中有一些变量不希望被修改的话那就有风险了。为了防止世界被破坏，为了维护私有变量不被修改，我们可以使用闭包。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> _flag = <span class="number">0</span>;

  <span class="keyword">return</span> {
    add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">return</span> a + b;
    },
    divide: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">return</span> a / b;
    }
  };
})();
</pre></td></tr></table></figure>

<p>外部代码只能访问返回的<code>add</code>和<code>divide</code>方法，内部的<code>_flag</code>变量是不能访问的。关于创建对象的一些方法的解释，可以参考我的<a href="http://classicemi.github.io/2014/04/22/javascript-pattern-02/">另一篇博文</a>，里面有较详细的解释。</p>
<p>利用自执行函数的特点，我们还可以很方便地为模块添加方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span><span class="params">(module)</span> {</span>
  module.subtract = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a - b;
  }
})(math);
</pre></td></tr></table></figure>

<p>模块在全局变量中的名称可能会与其他的模块产生冲突，例如<code>$</code>符号，虽然使用方便，但多个模块可能都会用它作为自己的简写，例如<a href="http://www.jquery.com/" target="_blank">jQuery</a>。我们可以在模块的组织代码中用<code>$</code>作为形参，将模块的全名变量作为参数传入，可起到防冲突的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> math = (<span class="function"><span class="keyword">function</span><span class="params">($)</span> {</span>
  <span class="comment">// 这里的$指的就是Math</span>
})(math);
</pre></td></tr></table></figure>

<p>模块的构建思想便是通过这样的方式逐渐演化而来，下面将通过介绍一些JS模块化编程的标准来展示如何组织，管理和编写模块。</p>
<h2 id="AMD_与_CMD"><code>AMD</code> 与 <code>CMD</code></h2>
<p>在JavaScript模块化编程的世界中，有两个规范不得不提，它们分别是<a href="https://github.com/amdjs/amdjs-api/wiki/AMD/" target="_blank">AMD</a>和<a href="https://github.com/cmdjs/specification/blob/master/draft/module.md/" target="_blank">CMD</a>。现在的JS库或框架，凡是模块化的，一般都是遵循了这两个规范其中之一。</p>
<h3 id="AMD（Asynchronous_Module_Definition）">AMD（Asynchronous Module Definition）</h3>
<p><strong>CommonJS</strong><br>在说AMD之前，先要提一下<a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank">CommonJS</a>。CommonJS是为了弥补JavaScript标准库过少的缺点而产生的，由于JS没有模块机制（<a href="http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts" target="_blank">ES6</a>引入了模块系统，但浏览器全面支持估计还有好几年），CommonJS就帮助JS实现模块的功能。现在很热门的<a href="http://nodejs.org/" target="_blank">Node.js</a>就是CommonJS规范的一个实现。</p>
<p>CommonJS在模块中定义方法要借助一个全局变量<code>exports</code>，它用来生成当前模块的API：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">/* math module */</span>

exports.add = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
  <span class="keyword">return</span> a + b;
};
</pre></td></tr></table></figure>

<p>要加载模块就要使用CommonJS的一个全局方法<code>require()</code>。加载之前实现的<code>math</code>模块像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);
</pre></td></tr></table></figure>

<p>加载后<code>math</code>变量就是这个模块对象的一个引用，要调用模块中的方法就像调用普通对象的方法一样了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);
math.add(<span class="number">1</span>, <span class="number">3</span>);
</pre></td></tr></table></figure>

<p>总之，CommonJS就是一个模块加载器，可以方便地对JavaScript代码进行模块化管理。但它也有缺点，它在设计之初并没有完全为浏览器环境考虑，浏览器环境的特点是所有的资源，不考虑本地缓存的因素，都需要从服务器端加载，加载的速度取决于网络速度，而CommonJS的模块加载过程是同步阻塞的。也就是说如果<code>math</code>模块体积很大，网速又不好的时候，整个程序便会停止，等待模块加载完成。</p>
<p>随着浏览器端JS资源的体积越来越庞大，阻塞给体验带来的不良影响也越来越严重，终于从，在CommonJS社区中有了不同的声音，<code>AMD</code>规范诞生了。</p>
<p><strong>AMD</strong><br>它的特点便是异步加载，模块的加载不会影响其他代码的运行。所有依赖于某个模块的代码全部移到模块加载语句的回调函数中去。AMD的<code>require()</code>语句接受两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="comment">// require([module], callback)</span>
<span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span><span class="params">(math)</span> {</span>
  math.add(<span class="number">1</span>, <span class="number">3</span>);
});
</pre></td></tr></table></figure>

<p>在回调函数中，可以通过<code>math</code>变量引用模块。</p>
<p>AMD规范也规定了模块的定义规则，使用<code>define()</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>define(id?, dependencies?, factory);
</pre></td></tr></table></figure>

<p>它接受三个参数：<br><em>id</em><br>这是一个可选参数，相当于模块的名字，加载器可通过id名加载对应的模块。如果没有提供id，加载器会将模块文件名作为默认id。</p>
<p><em>dependencies</em><br>可选，接受一个数组参数，传入当前对象依赖的对象id。</p>
<p><em>factory</em><br>回调函数，在依赖模块加载完成后会调用，它的参数是所有依赖模块的引用。回调函数的返回值就是当前对象的导出值。</p>
<p>用AMD规范实现一个简单的模块可以这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>define(<span class="string">'foo'</span>, [<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span><span class="params">(math)</span> {</span>
  <span class="keyword">return</span> {
    increase: <span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span>
      <span class="keyword">return</span> math.add(x, <span class="number">1</span>);
    }
  };
});
</pre></td></tr></table></figure>

<p>如果省去id和dependencies参数的话，就是一个完全的匿名模块。factory的参数将为默认值<code>require</code>，<code>exports</code>和<code>module</code>加载器将完全通过文件路径的方式加载模块，同时如果有依赖模块的话可通过<code>require</code>方法加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);

  exports.increase = <span class="function"><span class="keyword">function</span><span class="params">(x)</span> {</span>
    <span class="keyword">return</span> math(x, <span class="number">1</span>);
  };
});
</pre></td></tr></table></figure>

<p>AMD规范也允许对加载进行一些配置，配置选项不是必须的，但灵活更改配置，会给开发带来一些方便。</p>
<p><strong>baseUrl</strong> 以字符串形式规定根目录的路径，以后在加载模块时都会以该路径为标准。在浏览器中，工作目录的路径就是运行脚本的网页所在的路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>{
  baseUrl: <span class="string">'./foo/bar'</span>
}
</pre></td></tr></table></figure>

<p><strong>path</strong> 可以指定需加载模块的路径，模块名与路径以键-值对的方式写在对象中。如果一个模块有多个可选地址，可以将这些地址写在一个数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>{
  path: {
    <span class="string">'foo'</span>: <span class="string">'./bar'</span>
  }
}
</pre></td></tr></table></figure>

<p>关于模块路径的设置项还有<strong>packages</strong>，<strong>map</strong>。</p>
<p><strong>shim</strong><br>对于某些没有按照AMD规范编写的模块，比如jQuery，来说，要使它们能被加载器加载，需要用<code>shim</code>方法为其配置一些属性。在<code>main</code>模块中，用<code>require.config()</code>方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="built_in">require</span>.config({
  shim: {
    <span class="string">'jquery'</span>: {
      exports: <span class="string">'$'</span>
    },
    <span class="string">'foo'</span>: {
      deps: [
        <span class="string">'bar'</span>,
        <span class="string">'jquery'</span>
      ],
      exports: <span class="string">'foo'</span>
    }
  }
});
</pre></td></tr></table></figure>

<p>之后再用加载器加载就可以了。</p>
<p>目前实现了AMD规范的库有很多，比较有名的是<a href="http://requirejs.org/" target="_blank">Require.js</a>。</p>
<h3 id="CMD（Common_Module_Definition）">CMD（Common Module Definition）</h3>
<p>CMD在很多地方和AMD有相似之处，在这里我只说两者的不同点。</p>
<p>首先，CMD规范和CommonJS规范是兼容的，相比AMD，它简单很多。遵循CMD规范的模块，可以在Node.js中运行。</p>
<p><strong>define</strong><br>与AMD规范不同的是CMD规范中不使用<code>id</code>和<code>deps</code>参数，只保留<code>factory</code>。其中：<br>1.<code>factory</code>接收对象/字符串时，表明模块的接口就是对象/字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>define({ <span class="string">'foo'</span>: <span class="string">'bar'</span> });

define(<span class="string">'My name is classicemi.'</span>);
</pre></td></tr></table></figure>

<p><strong>define.cmd</strong><br>其值为一个空对象，用于判断页面中是否有CMD模块加载器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> && define.cmd) {
  <span class="comment">// 使用CMD模块加载器编写代码</span>
}
</pre></td></tr></table></figure>

<p><strong>require</strong><br>此函数同样用于获取模块接口。如需异步加载模块，使用<code>require.async</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="built_in">require</span>.async(<span class="string">'math'</span>, <span class="function"><span class="keyword">function</span><span class="params">(math)</span> {</span>
    math.add(<span class="number">1</span>, <span class="number">2</span>);
  });
});
</pre></td></tr></table></figure>

<p>我们可以发现，<code>require(id)</code>的写法和CommonJS一样是以同步方式加载模块。要像AMD规范一样异步加载模块则使用<code>define.async</code>方法。</p>
<p><strong>exports</strong><br>此方法用于模块对外提供接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="comment">// 对外提供foo属性</span>
  exports.foo = <span class="string">'bar'</span>;

  <span class="comment">// 对外提供add方法</span>
  exports.add = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> a + b;
  }
});
</pre></td></tr></table></figure>

<p>提供接口的另一个方法是直接return包含接口键值对的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="keyword">return</span> {
    foo: <span class="string">'bar'</span>,
    add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">return</span> a + b;
    }
  }
});
</pre></td></tr></table></figure>

<p>但是注意，不能用exports输出接口对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  exports = {
    foo: <span class="string">'bar'</span>,
    add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> {</span>
      <span class="keyword">return</span> a + b;
    }
  }
});
</pre></td></tr></table></figure>

<p><strong>这样写是错误的！</strong><br>替代方式是这样写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span></span> {
  <span class="built_in">module</span>.exports = {
    foo: <span class="string">'bar'</span>,
    add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span></span> {
      <span class="keyword">return</span> a + b;
    }
  }
});
</pre></td></tr></table></figure>

<p>之前错误的原因是在<code>factory</code>内部，<code>exports</code>实际上是<code>module.exports</code>的一个引用，直接给<code>exports</code>赋值是不会改变<code>module.exports</code>的值的。</p>
<p>在module对象上，除了有上面提到的<code>exports</code>以外，还有一些别的属性和方法。<br><strong>module.id</strong><br>模块的标识。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>define(<span class="string">'math'</span>, [], <span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="comment">// module.id 的值为 math</span>
});
</pre></td></tr></table></figure>

<p><strong>module.uri</strong><br>模块的绝对路径，由模块系统解析得到。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  console.log(module.uri); <span class="comment">// http://xxx.com/path/</span>
});
</pre></td></tr></table></figure>

<p><strong>module.dependencies</strong><br>值为一个数组，返回本模块的依赖。</p>
<h2 id="Require-js_和_Sea-js">Require.js 和 Sea.js</h2>
<p>之前在说AMD规范的时候提到了Require.js。它是AMD规范的代表性产品。另一个<a href="http://seajs.org/" target="_blank">Sea.js</a>在前端界也是赫赫有名了，CMD规范实际上就是它的产出。它们之间的区别也很能表现AMD和CMD规范之间的区别。</p>
<p>AMD的依赖需要<strong>前置书写</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>define([<span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="function"><span class="keyword">function</span><span class="params">(foo, bar)</span> {</span>
  foo.add(<span class="number">1</span>, <span class="number">2</span>);
  bar.subtract(<span class="number">3</span>, <span class="number">4</span>);
});
</pre></td></tr></table></figure>

<p>CMD的依赖<strong>就近书写</strong>即可，不需要提前声明：<br>同步式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  <span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>);
  foo.add(<span class="number">1</span>, <span class="number">2</span>);
  ...
  <span class="keyword">var</span> bar = <span class="built_in">require</span>(<span class="string">'bar'</span>);
  bar.subtract(<span class="number">3</span>, <span class="number">4</span>);
});
</pre></td></tr></table></figure>

<p>异步式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>define(<span class="function"><span class="keyword">function</span><span class="params">(require, exports, module)</span> {</span>
  ...
  <span class="built_in">require</span>.async(<span class="string">'math'</span>, <span class="function"><span class="keyword">function</span><span class="params">(math)</span> {</span>
    math.add(<span class="number">1</span>, <span class="number">2</span>);
  });
  ...
});
</pre></td></tr></table></figure>

<p>虽然AMD也可以用和CMD相似的方法，但不是官方推荐的。</p>
<p>之前在介绍CMD的API时，我们可以发现其API职责专一，例如同步加载和异步加载的API都分为<code>require</code>和<code>require.async</code>，而AMD的API比较多功能。</p>
<p>总而言之，引用玉伯的总结：</p>
<ol>
<li>Require.js同时适用于浏览器端和服务器环境的模块加载。Sea.js则专注于浏览器端的模块加载实现。通过Node扩展也可以运行于Node环境中。</li>
<li>Require.js -&gt; AMD，Sea.js -&gt; CMD。</li>
<li>RequireJS 在尝试让第三方类库修改自身来支持 RequireJS，目前只有少数社区采纳。Sea.js 不强推，采用自主封装的方式来“海纳百川”，目前已有较成熟的封装策略。</li>
<li>Sea.js的调试工具比较完备，Require.js调试比较不方便。</li>
<li>RequireJS 采取的是在源码中预留接口的形式，插件类型比较单一。Sea.js 采取的是通用事件机制，插件类型更丰富。</li>
</ol>
<p><em>怎么看都像是在自夸啊= =，当然它有这个资格</em></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="http://wiki.commonjs.org/wiki/CommonJS" target="_blank">CommonJS官网</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank">阮一峰博客</a></li>
<li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank">AMD Github</a></li>
<li><a href="https://github.com/cmdjs/specification/blob/master/draft/module.md" target="_blank">CMD Github</a></li>
<li><a href="http://seajs.org/" target="_blank">Sea.js</a></li>
<li><a href="http://requirejs.org/" target="_blank">Require.js</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>JavaScript本身不是一种模块化语言，设计者在创造JavaScript之初应该也没有想到这么一个脚本语言的作用领域会越来越大。以前一个页面的JS代码再多也不会多到哪儿去，而现在随着越来越多的JavaScript库和框架的出现，Single-page App的流行以及Node.js的迅猛发展，如果我们还不对自己的JS代码进行一些模块化的组织的话，开发过程会越来越困难，运行性能也会越来越低。因此，了解JS模块化编程是非常重要的。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(五)——工厂模式]]></title>
    <link href="http://classicemi.github.io/2014/05/03/javascript-pattern-05/"/>
    <id>http://classicemi.github.io/2014/05/03/javascript-pattern-05/</id>
    <published>2014-05-03T04:14:28.000Z</published>
    <updated>2014-05-03T04:14:05.000Z</updated>
    <content type="html"><![CDATA[<p>一般来说，创建对象的时候我们都习惯使用<code>new</code>关键字来调用constructor构造函数，但使用这种方式会有一些缺点，首先构造器函数的创建本身就是为了模仿其他一些面向对象语言的特性，有些人觉得这是<em>non-sense</em>；另一方面，在一个类中用<code>new</code>关键字调用其他类的构造函数，会造成两个类之间的耦合，设计模式应该要尽量避免这些影响代码可重用性的问题。</p>
<a id="more"></a>

<h2 id="简单工厂模式">简单工厂模式</h2>
<p>一个工厂可以生产同一类的多种物品，具体生产哪种就看客户下什么订单了。工厂模式也是一样，我们创建一个工厂类，它可以创建多种实例，由开发者指定。<br>假设有一个生产交通工具的工厂类<code>Vehicle</code>，它包含生成多种交通工具实例的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span><span class="params">()</span> {</span>}

Vehicle.prototype = {
  createVihicle: <span class="function"><span class="keyword">function</span><span class="params">(options)</span> {</span>
    <span class="keyword">var</span> vehicle;

    <span class="keyword">switch</span>(options.type) {
      <span class="keyword">case</span> <span class="string">'car'</span>:
        vehicle = <span class="keyword">new</span> Car();
        <span class="keyword">break</span>;
      <span class="keyword">case</span> <span class="string">'truck'</span>:
        vehicle = <span class="keyword">new</span> Truck();
        <span class="keyword">break</span>;
      <span class="keyword">default</span>:
        vehicle = <span class="keyword">new</span> Bike();
    }

    <span class="keyword">return</span> vehicle;
  }
};
</pre></td></tr></table></figure>

<p>在使用这个类生产对象的时候，传入<code>option</code>参数，在参数中的<code>type</code>属性规定我们需要的类型，构造函数就能够返回我们需要的对象类型了。使用这种方法，如果我们要添加新的交通工具类型也是很方便的，在工厂的<code>switch</code>中直接添加一个<code>case</code>就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="keyword">switch</span>(options.type) {
  <span class="keyword">case</span> <span class="string">'car'</span>:
    vehicle = <span class="keyword">new</span> Car();
    <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="string">'truck'</span>:
    vehicle = <span class="keyword">new</span> Truck();
    <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="string">'plane'</span>:
    vehicle = <span class="keyword">new</span> Plane();
    <span class="keyword">break</span>;
  <span class="keyword">default</span>:
    vehicle = <span class="keyword">new</span> Bike();
}
</pre></td></tr></table></figure>

<p>通过这种方式，将成员对象的创建工作转交给外部对象，可以像上述代码一样转交给独立的命名空间，像<code>Car</code>，<code>Truck</code>，<code>Plane</code>等，如果外部对象属于同一类的话，将它们组织为一个大类中的子类比较合理。</p>
<h2 id="工厂模式">工厂模式</h2>
<p>以上介绍的是简单工厂模式，简单工厂模式会把创建工作交给<strong>外部</strong>的类来做，这实际上会增加类的数量，并不利于代码的组织。真正的工厂模式会把创建工作交给子类来完成，父类只对创建过程中的一般性问题进行处理，这些处理会影响到每个子类，而子类之间相互独立，可以对创建过程进行一些定制化操作。</p>
<p>还是以生产交通工具为例，将交通工具父类改写为一个<strong>抽象类</strong>，它不负责直接生产交通工具，而是通过它派生出一些子类，这些子类代表不同的国家，不同的国家可以生产自己的交通工具。</p>
<p>将父类抽象化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span><span class="params">()</span> {</span>}

Vehicle.prototype = {
  createVihicle: <span class="function"><span class="keyword">function</span><span class="params">(options)</span> {</span>
    <span class="comment">// 这里不直接生产，如果直接调用会抛出错误</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unsupported operation on an abstract class.'</span>)
  }
};
</pre></td></tr></table></figure>

<p>不同的国家作为子类，子类首先对父类进行继承，然后实现自己的<code>createVehicle</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">China</span><span class="params">()</span> {</span>}

<span class="comment">// 继承方法</span>
extend(China, Vehicle);

<span class="comment">// 实现自己的createVehicle方法</span>
China.prototype.createVehicle = <span class="function"><span class="keyword">function</span><span class="params">(options)</span> {</span>
  <span class="keyword">var</span> vehicle;

  <span class="keyword">switch</span>(options.type) {
    <span class="keyword">case</span> <span class="string">'car'</span>:
      vehicle = <span class="keyword">new</span> Car();
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'truck'</span>:
      vehicle = <span class="keyword">new</span> Truck();
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      vehicle = <span class="keyword">new</span> Bike();
  }

  <span class="keyword">return</span> vehicle;
}
</pre></td></tr></table></figure>

<p>以后要生产交通工具的时候就调用<code>China</code>子类的<code>createVehicle</code>方法就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> chinaVehicle = <span class="keyword">new</span> China();
<span class="keyword">var</span> myCar = chinaVehicle.createVehicle({ type: <span class="string">'Car'</span> });
</pre></td></tr></table></figure>

<p>一般性的代码集中在父类中，个性化的代码在子类中单独定制。</p>
<h2 id="工厂模式适用场合">工厂模式适用场合</h2>
<p>子类的共同点是它们都实现了同一批接口，尽管内部细节并不尽相同。生产对象的方法有一个选择性的过程，这种选择可以是开发者自定的，比如需要生产何种交通工具，也可以是自动选择的，比如根据浏览器环境生产合适的XHR对象。对于相似性很高，实现了同一类接口的对象，工厂模式是比较合适的。</p>
<p>另外的一大好处就是子类的一些设置代码可以全部放在父类的构造器函数中，不需要在每个子类的构造函数中重复运行同样的代码，只需要在父类的代码中实现一次就好。子类只需要专注于实现自己的方法，不用考虑别的问题。</p>
<p>最后一点则是如果一个类中包含了很多更小的子类作为自己的组成部分，那么替换这些子类的工作会很简单，因为工厂模式降低了模块之间的耦合度，一个模块并不会依赖于其某一组成部分。</p>
]]></content>
    <summary type="html"><![CDATA[<p>一般来说，创建对象的时候我们都习惯使用<code>new</code>关键字来调用constructor构造函数，但使用这种方式会有一些缺点，首先构造器函数的创建本身就是为了模仿其他一些面向对象语言的特性，有些人觉得这是<em>non-sense</em>；另一方面，在一个类中用<code>new</code>关键字调用其他类的构造函数，会造成两个类之间的耦合，设计模式应该要尽量避免这些影响代码可重用性的问题。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(四)——单体模式和链式调用]]></title>
    <link href="http://classicemi.github.io/2014/04/27/javascript-pattern-04/"/>
    <id>http://classicemi.github.io/2014/04/27/javascript-pattern-04/</id>
    <published>2014-04-27T04:38:28.000Z</published>
    <updated>2014-05-02T11:29:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="设计模式分类">设计模式分类</h2>
<p>接下来就正式进入设计模式的介绍了，JavaScript设计模式有很多</p>
<h2 id="单体模式">单体模式</h2>
<p>在多种Javascript设计模式中，<strong>单体模式</strong>是最简单，也是最基础的设计模式。它基础到似乎不太像是一种设计模式，因为我们在编写代码的过程中随时都会用到，并不需要过多思考，这是它简单的一面。同时，它不仅可以单独存在，甚至也可以成为其他较高级设计模式的组成部分，这也是为什么说它基础的原因。</p>
<a id="more"></a>

<h3 id="基本结构">基本结构</h3>
<p>既然说了单体模式是非常简单的，它的结构也是很简单的。最简单的单体结构实际上就是一个对象字面量：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> Singleton = {
  attribute1: <span class="literal">true</span>,
  attribute2: <span class="number">1</span>,

  method1: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
  },
  method2: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
  }
}
</pre></td></tr></table></figure>

<p>这就是一个基本的单体结构了。</p>
<p>但是，不是任何对象字面量都可以被称作为单体结构的，单体结构应该是一个只能被实例化一次，并且可以通过一个访问点访问的类。所谓访问点，可以理解为一个变量，这个变量在全局范围内可以访问到，并且只有一个。</p>
<h3 id="单体结构的作用">单体结构的作用</h3>
<p>那么单体结构的作用是什么呢，难道只是用来创建一个实例化的对象这么简单吗？</p>
<p><strong>命名空间</strong><br>当然不是的，单体最显而易见的作用就是划分命名空间。单体结构在页面中有一个访问点，那么单体中保存的所有属性和方法也就可以从这个访问点访问了，通过点运算符的形式。而且也只有通过访问点才可以访问到。Javascript中的所有变量都是可以被改写的，当一个程序员维护多个变量的时候，如果不将他们归类到命名空间中去的话，一旦变量被修改，查找起来将非常麻烦。同时，一个命名良好的命名空间名称也可以提醒其他的程序员不要随便修改其中的变量。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> Classicemi = {
  setName: <span class="function"><span class="keyword">function</span><span class="params">(name)</span> {</span>
    ...
  },
  <span class="comment">// 其他方法</span>
}
</pre></td></tr></table></figure>

<p>在其他地方访问<code>setName</code>方法的时候，一定要通过<code>Classicemi.setName</code>才能访问的到，这可以提醒其他程序员这个方法的作用和声明的地点。通过命名空间将相似的方法组合到一起也可以增加代码的文档性。另一方面，网页上的Javascript代码会根据其用途有不同的划分，分不同的人来维护。例如JS库代码，广告代码等。为了避免彼此之间产生冲突，在全局对象中也可以给不同用途的代码划分各自的命名空间，也就是存到各个单体中。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> Classicemi = {};

Classicemi.Common = {
  ...
};

Classicemi.ErrorCodes = {
  ...
};
</pre></td></tr></table></figure>

<p><strong>网页专用代码包装器</strong><br>这是单体常见用法的一个示例。<br>在一个网站中，有些Javascript代码是整个网站都要用到的，比如框架，库等。而有些代码是特定的网页才会用到，例如对一个页面中的DOM元素添加事件监听等。一般我们会通过给页面的<code>load</code>事件创建一个<code>init</code>方法来对所有需要的操作进行初始化，将所有的初始化代码放在一个方法中。<br>比如含有一个表单的页面，我们要取消submit的默认行为并添加ajax交互。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>Classicemi.RegPage = {
  FORM_ID: <span class="string">'reg-form'</span>,
  OUTPUT_ID: <span class="string">'reg-results'</span>,

  <span class="comment">// 表单处理方法</span>
  handleSubmit: <span class="function"><span class="keyword">function</span><span class="params">(e)</span> {</span>
    e.preventDefult();
    ...
  } ,
  sendRegistration: <span class="function"><span class="keyword">function</span><span class="params">(data)</span> {</span>
    ... <span class="comment">// 发送XHR请求</span>
  },
  ...

  <span class="comment">// 初始化方法</span>
  init: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    Classicemi.RegPage.formEl = $(Classicemi.RegPage.FORM_ID);
    Classicemi.RegPage.outputEl = $(Classicemi.RegPage.OUTPUT_ID);

    addEvent(Classicemi.RegPage.FormEl, <span class="string">'submit'</span>, Classicemi.RegPage.handleSubmit); <span class="comment">// 添加事件</span>
  }
};

<span class="comment">// 页面加载后运行初始化方法</span>
addLoadEvent(Classicemi.PageName.init);
</pre></td></tr></table></figure>

<p>这样处理之后，对于不支持XHR的老式浏览器，可以按照原有方式发送表单数据并刷新页面。而现代浏览器中则可以阻止表单提交的默认行为，改由ajax对页面进行部分刷新，提供更好的用户体验。</p>
<h3 id="在单体中表示私用成员">在单体中表示私用成员</h3>
<p>对象中有时候有些属性和方法是需要进行保护，避免被修改的，这些成员称为私用成员。在单体中声明私用成员也是保护变量的一个好方法，另外，单体中创建私用成员的另一个好处在于由于单体只会被实例化一次，定义私用成员的时候就不用过多考虑内存浪费的问题。</p>
<p><strong>伪私用成员（下划线表示法）</strong><br>通过特殊命名的变量来提醒其他开发者不要直接访问对象成员的方法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>Classicemi.Singleton = {
  <span class="comment">// 私用成员</span>
  _privateMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
  },

  <span class="comment">// 公开成员</span>
  publicMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
  }
}
</pre></td></tr></table></figure>

<p>在该单体的方法中，可以通过<code>this</code>访问其他方法，但这会有一定的风险，因为在特殊情况下<code>this</code>不一定指向该单体。因此还是将调用名称写全是最安全的做法。</p>
<p><strong>使用闭包</strong><br>加下划线的方法毕竟是假的，使用闭包才能创建真正意义上的私用成员。我们知道Javascript只存在函数作用域，因此要利用闭包的特性就不能使用对象字面量的形式，而要通过构造函数返回来实现单体对象的创建了。第一步，我们通过一个构造函数返回一个空对象，这就是单体对象的初始化：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">var</span> Classicemi.Singleton = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> {};
})();
</pre></td></tr></table></figure>

<p>我们通过一个自执行构造函数返回单体对象的实例，下面就可以在这个构造函数中添加我们需要的私用对象了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> Classicemi.Singleton = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// 私用属性</span>
  <span class="keyword">var</span> privateAttribute = <span class="literal">true</span>;

  <span class="comment">// 私用方法</span>
  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span><span class="params">()</span> {</span>
    ...
  }
  <span class="keyword">return</span> {};
})();
</pre></td></tr></table></figure>

<p>可以公开访问的公开属性和方法可以写在构造函数返回的对象中：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> Classicemi.Singleton = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// 私用属性</span>
  <span class="keyword">var</span> privateAttribute = <span class="literal">true</span>;

  <span class="comment">// 私用方法</span>
  <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span><span class="params">()</span> {</span>
    ...
  }
  <span class="keyword">return</span> {
    publicAttribute: <span class="literal">false</span>,

    publicMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      ...  
    }
  };
})();
</pre></td></tr></table></figure>

<p>这就是用闭包创建私有成员的方法，这种单体模式又被成为<strong>模块模式（Module Pattern）</strong>，我们创建的单体可以作为模块，对代码进行组织，并划分命名空间。</p>
<p>和之前说到的下划线表示私用成员方法比较起来，最大的优点就是可以创建真正的私用成员，使其不会在构造函数之外被随意修改。同时，由于单体只会被实例化一次，不用担心内存浪费的问题。单体模式是Javascript中最简单，最流行的模式之一。</p>
<h3 id="惰性实例化单体">惰性实例化单体</h3>
<p>单体一般会在页面加载过程中进行实例化，如果单体的体积比较大的话，可能会对加载速度造成影响。对于体积比较大，在页面加载时也暂时不会起作用的单体，我们可以通过<strong>惰性加载（lazy loading）</strong>的方式进行实例化，也就是在需要的时候再进行实例化。</p>
<p>要实现惰性加载，我们要借助一个静态方法来实现。在单体的命名空间中，我们声明这样一个方法<code>getInstance()</code>。这个方法会对单体是否已经进行了实例化进行检测，如果还没有实例，则会创建并返回实例。如果已经实例化过了，则会返回现有实例。</p>
<p>实现惰性加载，我们要把原单体构造函数中的所有成员转移到一个内部的新构造函数中去：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre>Classicemi.Singleton = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">constructor</span><span class="params">()</span> {</span>
    <span class="comment">// 私用属性</span>
    <span class="keyword">var</span> privateAttribute = <span class="literal">true</span>;

    <span class="comment">// 私用方法</span>
    <span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span><span class="params">()</span> {</span>
      ...
    }
    <span class="keyword">return</span> {
      publicAttribute: <span class="literal">false</span>,

      publicMethod: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        ...  
      }
    };
  }
})();
</pre></td></tr></table></figure>

<p>这个内嵌构造函数不能从闭包外部访问，那么在闭包内部返回对象中的<code>getInstance</code>方法可以有访问<code>constructor</code>方法的特权，可以保证<code>constructor</code>方法只会被我们控制。</p>
<p>在<code>getInstance()</code>方法内部，首先要对单体是否已经实例化进行检查，如果已经实例化过，就将其返回。如果没有实例化，就调用<code>constructor</code>方法。我们需要一个变量来保存实例化后的单体。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre>Classicemi.Singleton = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> uniqueInstance; <span class="comment">// 保存实例化后的单体</span>

  <span class="function"><span class="keyword">function</span> <span class="title">constructor</span><span class="params">()</span> {</span>
    ...
  }

  <span class="keyword">return</span> {
    getInstance: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">if</span> (!uniqueInstance) {
        uniqueInstance = constructor();
      }
      <span class="keyword">return</span> uniqueInstance;
    }
  }
})();
</pre></td></tr></table></figure>

<p>单体的构造函数像这样被改写后，调用其方法的代码就要由这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Classicemi.Singleton.publicMethod();
</pre></td></tr></table></figure>

<p>改写为：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>Classicemi.Singleton.getInstance().publicMethod();
</pre></td></tr></table></figure>

<p>惰性加载的使用可以避免不必要的单体在页面加载时实例化影响加载速度，但引入一个<code>getInstance()</code>方法也会在一定程度上增加代码的复杂性，因此惰性加载应该在必要的时候再使用。</p>
<h3 id="分支">分支</h3>
<p><strong>分支（branching）</strong>技术的意义在于根据不同的条件，对单体进行不同的实例化过程。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>                    <span class="function"><span class="keyword">constructor</span>
                         │<span class="title">condition</span>
            ┌────────────┼────────────┐
            │            │            │
<span class="title">return</span>   <span class="title">branch1</span>      <span class="title">branch2</span>      <span class="title">branch3</span></span>
</pre></td></tr></table></figure>

<p>在构造函数中存在不同的实例对象，针对condition判断条件的不同返回值，构造函数返回不同的对象作为单体的实例。例如对不同的浏览器来说，支持的<code>XHR</code>对象不一样，大多数浏览器中是<code>XMLHttpRequest</code>的实例，早期的IE浏览器中是某种<code>ActiveX</code>的实例。我们在创建<code>XHR</code>对象的时候，可以根据不同浏览器的支持情况返回不同的实例，like this：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="keyword">var</span> XHRFactory = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> standard = {
    createXHR: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();
    }
  };
  <span class="keyword">var</span> activeX = {
    createXHR: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Msxml2.XMLHTTP'</span>);
    }
  };
  <span class="keyword">var</span> activeOld = {
    createXHR: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsofe.XMLHTTP'</span>);
    }
  }

  <span class="keyword">var</span> testObj;
  <span class="keyword">try</span> {
    testObj = standard.createXHR();
    <span class="keyword">return</span> standard;
  } <span class="keyword">catch</span> (e) {
    <span class="keyword">try</span> {
      testObj = activeX.createXHR();
      <span class="keyword">return</span> standard;
    } <span class="keyword">catch</span> (e) {
      <span class="keyword">try</span> {
        testObj = activeOld.createXHR();
        <span class="keyword">return</span> standard;
      } <span class="keyword">catch</span> (e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'No XHR object found in this environment.'</span>);
      }
    }
  }
})();
</pre></td></tr></table></figure>

<p>通过<code>try-catch</code>语句对浏览器<code>XHR</code>的支持性进行测试同时防止抛出错误，这样不同浏览器都能创建出自己支持的<code>XHR</code>对象的实例。</p>
<h2 id="单体模式之利弊">单体模式之利弊</h2>
<h3 id="单体模式之利">单体模式之利</h3>
<ol>
<li>单体模式能很好的<strong>组织代码</strong>，由于单体对象只会实例化一次，单体对象中的代码可以方便地进行维护。</li>
<li>单体模式可以生成自己的<strong>命名空间</strong>，防止自己的代码被别人随意修改。</li>
<li><strong>惰性实例化</strong>，有助于性能的提升。</li>
<li><strong>分支</strong>，针对特定环境定制专属的方法。</li>
</ol>
<h3 id="单体模式之弊">单体模式之弊</h3>
<p>类之间的耦合性可能增强，因为要通过命名空间去对一些方法进行访问，强耦合的后果会不利于单元测试。</p>
<h2 id="链式调用">链式调用</h2>
<p>说起链式调用，绝大多数的前端开发者一定会马上想到大名鼎鼎的<a href="http://jquery.com/" target="_blank"><strong>jQuery</strong></a>，这说明jQuery对开发者思想的束缚还真是深啊。。。</p>
<p>Anyway，jQuery的链式调用特性确实是给开发带来了很多的便利，一条语句可以完成几条语句的工作。那么链式调用是怎么实现的呢？</p>
<p>要实现链式调用其实是利用JavaScript的一些语法特性，主要分为两个部分：</p>
<ol>
<li>创建包含需要操作的HTML元素的对象。</li>
<li>对这个HTML元素进行操作的方法。</li>
</ol>
<p>将所有的方法都定义在构造器函数prototype属性所指的对象中，这样所有的实例都可以调用这些方法，并且所有的方法都返回调用它们的实例的引用。这样就实现了一个基本的链式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_$</span><span class="params">(els)</span> {</span>
    <span class="keyword">this</span>.elements = [];
    ... <span class="comment">// 通过一系列操作将匹配元素存入this.elements</span>
  }

  window.$ = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="comment">// 对外接口</span>
    <span class="keyword">return</span> <span class="keyword">new</span> _$(<span class="built_in">arguments</span>);
  }
})();
</pre></td></tr></table></figure>

<p>接下来就可以在构造器函数的原型所指对象中添加我们需要的方法了，我们可以根据需要添加DOM方法，ajax方法等，然后就可以完成一个小JS库了~</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_$</span><span class="params">(els)</span> {</span>
    ...
  }

  _$.prototype = {
    each: <span class="function"><span class="keyword">function</span><span class="params">(fn)</span> {</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="keyword">this</span>.length; i &lt; len; i++) {
        fn.call(<span class="keyword">this</span>, <span class="keyword">this</span>.elements[i]);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
    ...
  }
})();
</pre></td></tr></table></figure>

<p>关键的一点就是每个方法的最后都是<code>return this;</code>，它返回调用方法的实例引用，这样我们可以继续让这个<code>this</code>去调用其他方法，从而实现链式调用。</p>
<p><strong>使用回调</strong><br>回调的模式如果按照常规的方式运用在一些取值器方法上的时候，可能会给使用者造成一些麻烦。因为使用取值器的时候，可能下一步我们需要对取到的值进行一些操作，而链式调用返回的是对象本身。</p>
<p>为了保持链式调用能使用，<code>return this;</code>是不能动的，那么要对取到的值进行操作的话，就应该在取值器内部进行，将我们需要的操作过程封装成函数传入取值器，将值作为自定义函数的参数，这就是典型的回调函数思想。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_$</span><span class="params">(els)</span> {</span>
    ...
  }

  _$.prototype = {
    getValue: <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> {</span>
      callback.call(<span class="keyword">this</span>, <span class="keyword">this</span>.value); <span class="comment">// 通过传入回调函数对取到的值进行操作</span>
      <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 同时不影响继续链式调用</span>
    }
    ...
  }
})();
</pre></td></tr></table></figure>

]]></content>
    <summary type="html"><![CDATA[<h2 id="设计模式分类">设计模式分类</h2>
<p>接下来就正式进入设计模式的介绍了，JavaScript设计模式有很多</p>
<h2 id="单体模式">单体模式</h2>
<p>在多种Javascript设计模式中，<strong>单体模式</strong>是最简单，也是最基础的设计模式。它基础到似乎不太像是一种设计模式，因为我们在编写代码的过程中随时都会用到，并不需要过多思考，这是它简单的一面。同时，它不仅可以单独存在，甚至也可以成为其他较高级设计模式的组成部分，这也是为什么说它基础的原因。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用 CSS3 Flexible Boxes 布局]]></title>
    <link href="http://classicemi.github.io/2014/04/26/css-flexible-boxes/"/>
    <id>http://classicemi.github.io/2014/04/26/css-flexible-boxes/</id>
    <published>2014-04-26T12:51:28.000Z</published>
    <updated>2014-04-26T09:00:12.000Z</updated>
    <content type="html"><![CDATA[<p>Flexible Box是什么？Flexible意为可伸缩的，Box意为盒子，可以理解为一种新式的盒模型——<strong>伸缩盒模型</strong>。由<a href="http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/" target="_blank">CSS3规范</a>提出，这是在原有的大家非常熟悉的<code>block</code>, <code>inline-block</code>, <code>inline</code>的基础上延伸出的新一代布局模式。</p>
<h2 id="浏览器兼容性">浏览器兼容性</h2>
<p>作为非常现实的开发者，是否对一个新技术进行关注，首先要考虑它的浏览器兼容性如何。我们的伸缩盒模型的浏览器兼容性看起来还是相当不错的。</p>
<a id="more"></a>

<p><img src="/img/flexible-box-compatibility.jpg" alt=""><br>可以看到，现代浏览器基本上都支持了，IE10开始也支持了（IE和Safari分别加<code>-ms-</code>和<code>-webkit-</code>前缀即可），移动端的支持情况也比较良好，唯一不支持的平台只有Opera了，咱不带他玩→_→</p>
<p>因此，奥巴马同志说：伸缩盒模型是好的，有前途的。（嗯嗯~）</p>
<h2 id="伸缩盒基本概念">伸缩盒基本概念</h2>
<p>伸缩盒的最大特点或者说优点就在于它考虑到了现今高昂的房价和人民日益增长的住宅需求之间的矛盾，房屋面积是有限的，但是我们的伸缩盒能够最合理最高效地把房子分给大家。面积多了，就给大家伙多分点；面积小了，就让各位挤一挤少分点，总而言之不会让任何一个人<strong>露宿街头</strong>的（overflow）！</p>
<p>既然我们提到了房子和住户的关系，那么住户的排列自然需要沿一定的方向。对于块级元素来说，布局的延伸方向是自上而下的，也就是纵向。而对于行内元素来说，布局延伸方向是自左往右的，也就是横向。而伸缩盒呢，它的方向是可变的，既能纵向延伸，也能横向舒展，这取决于你的设置了。</p>
<h3 id="伸缩盒模型基本术语">伸缩盒模型基本术语</h3>
<p>伸缩盒模型的思想和普通的块级元素和行内元素的布局思想有较大的不同，它引入了一些新的概念和术语，通过下面这张图来了解一下：<br><img src="/img/flex_terms.png" alt=""></p>
<p><strong>Flex container 伸缩盒容器</strong><br>这就是用来分的房子，这是一间神奇的房子，要让它变得神奇，将<code>display</code>属性声明为<code>flex</code>或<code>inline-flex</code>即可~</p>
<p><strong>Flex item 伸缩项</strong><br>房子里的居民，他们都会占有自己应得的住房面积。</p>
<p>为了形象说明，我们用代码来解释。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"container"</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item item-1"</span>&gt;</span>item 1<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item item-2"</span>&gt;</span>item 2<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"item item-3"</span>&gt;</span>item 3<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</pre></td></tr></table></figure>

<p>CSS设置为：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>.container {
  display: flex;
  width: 300px;
  height: 100px;
  ...
}
</pre></td></tr></table></figure>

<p><strong>在这里<code>display: inline-flex;</code>好像也可以。</strong><br>对于其中的伸缩项元素，我们需要给他们事先安排好住房面积比例，我们就用最简单最健康的1:1:1吧~我们将比例声明在<code>flex</code>属性里</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>.item-1 {
  flex: 1;
  ...
}
.item-2 {
  flex: 1;
  ...
}
.item-3 {
  flex: 1;
  ...
}
</pre></td></tr></table></figure>

<p>Voilà!<br><img src="/img/flex-items.jpg" alt=""><br>我们的大房子被完美地平分成三个隔间了，三家平分房租！</p>
<p>如果有人想住大点的房子，我们直接改变<code>flex</code>的比例即可：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>.item-1 {
  flex: 1;
  ...
}
.item-2 {
  flex: 1;
  ...
}
.item-3 {
  flex: 2;
  ...
}
</pre></td></tr></table></figure>

<p><img src="/img/flex-items2.jpg" alt=""><br>是不是很方便？</p>
<p><strong>Axes 轴</strong><br>我们可以看到，图中有两条轴，分别标注了<strong>主轴</strong>和<strong>次轴</strong>（垂直于主轴）。然而实际上哪一条是主轴并不确定，是由我们来规定的。</p>
<ul>
<li><code>flex-direction</code> 此属性规定哪条轴为主轴。</li>
<li><code>justify-content</code> 此属性设置了伸缩项在主轴方向上的排列方式，这个稍后解释。</li>
<li><code>align-items</code> 此属性和上面的<code>justify-content</code>相对，表示伸缩项在次轴上的排列方式。</li>
<li><code>align-self</code> 此属性规定某一个特定的伸缩项元素在次轴上的布局方式，在某个元素上设置该属性会覆盖它的<code>align-items</code>属性。也就是这个属性会让某个元素更有个性，不走寻常路~</li>
</ul>
<p><strong>flex-direction</strong><br>当我们不想沿着默认的方向分房子的时候，我们可以改变<code>flex-direction</code>属性的值来改变主轴和方向，该属性默认的取值为row；</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>.container {
  flex: row-reverse;
  ...
}
</pre></td></tr></table></figure>

<p>顾名思义，这会让伸缩项的排列方向反过来：<br><img src="/img/flex-items-row-reverse.jpg" alt=""><br>当此属性设置为<code>column</code>时，主次轴就会对调，元素的排列方向也会随之改变：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>.container {
  flex-direction: column;
  ...
}
</pre></td></tr></table></figure>

<p><img src="/img/flex-items-column.jpg" alt=""><br>至于<code>flex: column-reverse</code>的含义就不用我多说了吧~</p>
<p><strong>justify-contents</strong><br>有的时候，大家挨着住，一点空隙都没有也会很难受，连个过道都没有，隐私也不能保证对吧。这个时候，我们可以改变分配政策了，不再按比例分配，而是定额分配，每个人的面积是确定的。多出的房屋面积改成公共区域。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>.item {
  width: 80px;
  ...
}
...
</pre></td></tr></table></figure>

<p><strong>设定了<code>width</code>属性后也要记得去掉<code>flex</code>属性的声明哦，不然<code>flex</code>属性的效果仍然会把<code>width</code>覆盖掉~</strong><br><strong>同时，如果<code>width</code>属性也不设定的话，元素宽度会表现为内容的宽度，which means 当伸缩项内部无内容时，将不会进行渲染，其表现就和<code>display: none;</code>一样。</strong><br>这时，在容器上声明<code>justify-content</code>属性就可以安排伸缩项的位置了：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class">.content</span> <span class="rules">{
  <span class="rule"><span class="attribute">justify-content</span>:<span class="value"> flex-start | flex-end | center | space-between | space-around</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><img src="/img/justify-content.png" alt=""></p>
<p><strong>align-items</strong><br>这项属性会改变次轴上元素排列的方式，对于本例来说原来次轴方向上元素的高度是表现为<code>height: 100%;</code>的，设定了<code>align-items</code>属性后，其高度表现就会发生改变了。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="class">.content</span> <span class="rules">{
  <span class="rule"><span class="attribute">align-items</span>:<span class="value"> flex-start | flex-end | center | baseline | stretch</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p>说到这里了，伸缩项具体的表现其实可以想象出来了，想象不出来的就自己动手试一试吧~</p>
<p><strong>order</strong><br>在伸缩项上声明此属性，可以无视HTML结构的顺序而按照<code>order</code>从小到大的顺序沿<code>flex-direction</code>方向排列。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>.item-1 {
  order: 3;
  ...
}
.item-2 {
  order: 1;
  ...
}
.item-3 {
  order: 2;
  ...
}
</pre></td></tr></table></figure>

<p><img src="/img/order.jpg" alt=""></p>
<p><strong>flex-wrap</strong><br>此属性的默认值为<code>nowrap</code>，也就是忽略伸缩项的宽度，管你要多少住房面积，通通按照<code>flex</code>属性说好的分配，不许换行。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="class">.container</span> <span class="rules">{
  <span class="rule"><span class="attribute">flex-wrap</span>:<span class="value"> nowrap | wrap | wrap-reverse
</span></span></span>}

<span class="class">.item</span> <span class="rules">{
  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">150</span>px</span></span>;
<span class="rule">}</span></span>
</pre></td></tr></table></figure>

<p><img src="/img/flex-wrap.jpg" alt=""></p>
<p><strong>flex-grow，flex-shrink和flex-basis</strong><br>上文提到的<code>flex</code>属性实际上是这三个属性的简写形式。这三个属性有相似性，都是表示项与项之间分配空间的相对比例关系，不同之处在于：</p>
<ul>
<li><code>flex-grow</code>属性：属性值为该伸缩项所占空间相对于其他伸缩项（声明了<code>flex</code>相关属性的项）的比值。</li>
<li><code>flex-shrink</code>属性：该伸缩项相对于其他伸缩项缩小的比值，也就是说当<code>flex-shrink: 3;</code>时，该项所占空间为其他项的1/3。</li>
<li><code>flex-basis</code>属性：属性值为该项所占空间占容器空间的百分比。</li>
</ul>
<p><strong>注意：</strong>对于<code>flex-basis</code>属性，当所有项的属性值相加&lt;=100%时，会严格按照百分比值来渲染。当属性值相加&gt;100%时，元素并不会溢出，而是表现为两两之间所占空间大小遵循相互的百分比比值。也就是说当存在三个伸缩项且<code>flex-basis</code>值都为<code>50%</code>时，表现行为与三个项均为<code>flex: 1;</code>一样。</p>
<p><strong>Flexible Boxes</strong>布局模式在响应式开发中尤其好用，对不同的终端，设置元素之间的空间分配关系将会变成一件非常简单的事。伸缩盒布局和响应式布局中流行的流体布局哪种更好，还是可以结合起来，就看各位开发者发挥自己的聪明才智了！</p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/" target="_blank">http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/flex</a></li>
<li><a href="http://www.zhangxinxu.com/wordpress/?p=1338" target="_blank">http://www.zhangxinxu.com/wordpress/?p=1338</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>Flexible Box是什么？Flexible意为可伸缩的，Box意为盒子，可以理解为一种新式的盒模型——<strong>伸缩盒模型</strong>。由<a href="http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/" target="_blank">CSS3规范</a>提出，这是在原有的大家非常熟悉的<code>block</code>, <code>inline-block</code>, <code>inline</code>的基础上延伸出的新一代布局模式。</p>
<h2 id="浏览器兼容性">浏览器兼容性</h2>
<p>作为非常现实的开发者，是否对一个新技术进行关注，首先要考虑它的浏览器兼容性如何。我们的伸缩盒模型的浏览器兼容性看起来还是相当不错的。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="http://classicemi.github.io/tags/css/"/>
    
      <category term="css3" scheme="http://classicemi.github.io/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(三)——继承]]></title>
    <link href="http://classicemi.github.io/2014/04/23/javascript-pattern-03/"/>
    <id>http://classicemi.github.io/2014/04/23/javascript-pattern-03/</id>
    <published>2014-04-23T13:28:28.000Z</published>
    <updated>2014-05-02T09:15:10.000Z</updated>
    <content type="html"><![CDATA[<p>继承这个东西在JavaScript中尤其复杂，我掌握得也不好，找工作面试的时候在这个问题上栽过跟头。JavaScript的继承方式属于原型式继承，非常灵活。因此JavaScript的继承方式除了基于类的继承之外还有基于原型的原型式继承。</p>
<a id="more"></a>

<h2 id="继承是什么">继承是什么</h2>
<p>看了这个词的第一反应我联想到了财产继承，在一般情况下，父母的遗产由子女继承，也就是说子女将会获得财产的使用权。而JavaScript中的继承与现实生活中的财产继承还是有区别的。首先，JavaScript中的父类和子类可以同时并存，而遗产么，什么样的财产叫遗产呢？其次，财产是花了就没了，而JS里的继承则是子类能够继承父类的方法，可以重复使用，减少代码量。当几个类都需要一个相似的方法时，使用继承可以从同一个类中继承相同的方法，而不用对每个类重复地复制粘贴了。</p>
<p>不用在定义上纠缠过久，下面讨论一下实现继承的一些方法。</p>
<h2 id="继承的基本方法">继承的基本方法</h2>
<p>开头便说到了JS的继承方式分为基于类的继承（简称类式继承）和基于原型链的继承（简称原型式继承）。</p>
<h3 id="类式继承">类式继承</h3>
<p>类式继承的特点就是使用函数声明类，通过<code>new</code>关键字创建实例。</p>
<p>创建类的方法很简单，一般可以写成这样：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">Blog</span><span class="params">(address)</span> {</span>
  <span class="keyword">this</span>.address = address;
}

Blog.prototype.getAddress = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.address;
}
</pre></td></tr></table></figure>

<p>创建该类的实例通过<code>new</code>关键字即可：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> blog = <span class="keyword">new</span> Blog(<span class="string">'classicemi.github.io'</span>);
blog.getAddress(); <span class="comment">// 'classicemi.github.io'</span>
</pre></td></tr></table></figure>

<p>当使用<code>new</code>关键字时，它和通过一般方式执行函数的区别在于函数的执行方式会改变。当使用<code>new</code>关键字执行<code>Blog</code>类的构造函数时，系统首先创建一个新对象，这个对象会继承自构造函数<code>Blog</code>的原型对象（新对象的原型就是构造函数的<code>prototype</code>属性）。再将<code>this</code>关键字绑定到新对象上，再返回该新对象。也就是说，构造函数用来对生成的新对象进行一些处理，使这个新对象具有某些特定的属性。</p>
<p>创建一个继承<code>Blog</code>的类就需要手工完成和<code>new</code>运算符相似的工作了。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">MyBlog</span><span class="params">(address, author)</span> {</span>
  Blog.call(<span class="keyword">this</span>, address);
  <span class="keyword">this</span>.author = author;
}
</pre></td></tr></table></figure>

<p>当通过<code>new</code>关键字调用<code>MyBlog</code>构造函数时，系统会创建一个新对象（这步是自动的，<code>this</code>即为这个新对象），然后在<code>this</code>上调用超类<code>Blog</code>的构造函数，再给<code>this</code>添加一些<code>MyBlog</code>类特有的不是继承自<code>Blog</code>类的属性，最后将新对象<code>this</code>返回（这步也是自动的）。</p>
<p>下面为了继承<code>Blog</code>类的方法，需要设置原型链，使<code>MyBlog</code>类能够在原型链上找到继承自<code>Blog</code>类的方法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>MyBlog.prototype = <span class="keyword">new</span> Blog(); <span class="comment">// MyBlog类的原型是Blog类的一个实例</span>
MyBlog.prototype.constructor = MyBlog; <span class="comment">// 上一步执行后prototype的constructor属性会变成Blog，需要修改回来</span>
MyBlog.prototype.getAuthor = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="comment">// 给MyBlog添加自己的方法</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.author;
}
</pre></td></tr></table></figure>

<p>通过这些操作后，<code>MyBlog</code>类就声明好了，它继承了<code>Blog</code>类的属性和方法，创建<code>MyBlog</code>类实例的方法和创建<code>Blog</code>类实例的方法一样，直接使用<code>new</code>关键字调用构造函数即可。</p>
<h3 id="原型式继承">原型式继承</h3>
<p>之前的类式继承是为了模仿其他一些面向对象语言的特点而创造的，并没有真正体现JavaScript语言本身的特点，下面要说的原型式继承则是利用JS的原型特性而实现的继承方式。</p>
<p>使用原型式继承时，不需要像类式继承一样用一个类（构造函数）来定义对象的结构，而可以用对象字面量的方式直接创建一个对象，这个对象是作为原型存在的，被称作原型对象(prototype object)。就像工厂生产车间里的模具一样，为以后生产出的零件提供了参考原型。</p>
<p>还是以之前的<code>Blog</code>和<code>MyBlog</code>类为例：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// Blog原型对象</span>
<span class="keyword">var</span> Blog = {
  address: <span class="string">'classicemi.github.io'</span>, <span class="comment">// 属性只是作为默认值，一般都会被改写</span>
  getAddress: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.address;
  }
};
</pre></td></tr></table></figure>

<p>这里没有像用一个构造函数来定义<code>Blog</code>类的结构，将方法添加在<code>Blog.prototype</code>上。这里定义的<code>Blog</code>对象只是作为原型存在，为继承<code>Blog</code>类的对象提供一些方法。</p>
<p>现在原型对象有了，要创建继承该原型对象对应的类的新类应该怎么做呢？利用JS的原型链特性，只要将新类的原型设为该原型对象即可。按照这种思路可以写出子类<code>MyBlog</code>的创建方法：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">MyBlogConstrucFunc</span><span class="params">()</span> {</span>}
MyBlogConstrucFunc.prototype = Blog;
<span class="keyword">var</span> MyBlog = <span class="keyword">new</span> MyBlogConstrucFunc();
</pre></td></tr></table></figure>

<p>通过<code>new</code>运算符调用<code>MyBlogConstrucFunc</code>函数，返回的是一个空对象，这个空对象的<code>prototype</code>属性指向原型对象<code>Blog</code>。在返回的空对象中，还可以添加<code>MyBlog</code>类自有的属性和方法。</p>
<p>不过通过这三行代码实现子类对超类的继承还是有些冗余，我们可以实现一个方法来实现对超类的继承，将超类作为该方法的参数传入并在最后将空对象返回即可。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">clone</span><span class="params">(object)</span> {</span>
  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> {</span>}
  F.prototype = object;
  <span class="keyword">return</span> <span class="keyword">new</span> F();
}
</pre></td></tr></table></figure>

<h3 id="Mixin_Class">Mixin Class</h3>
<p>以上所讨论的是比较严格的继承方式，有的时候，我们可能只想对某个函数进行重用，并不需要完全的继承，那么我们可以将函数以扩充的方式在类之间进行共享。对于重用频率比较高的方法，我们可以将它们归并在一个类中，然后用这个类去扩充其他的类。这种方法称为掺元类（mixin class）。这种处理方法在很多JS库（比如<code>jQuery</code>和<code>Underscore</code>）中都有用到，是一种扩充工具函数的好方法。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> Mixin = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
Mixin.prototype = {
  serialize: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> output = [];
    <span class="keyword">for</span>(key <span class="keyword">in</span> <span class="keyword">this</span>) {
      output.push(key + <span class="string">': '</span> + <span class="keyword">this</span>[key]);
    }
    <span class="keyword">return</span> output.join(<span class="string">', '</span>);
  }
  ...
};
</pre></td></tr></table></figure>

<p>为了能方便地将<code>Mixin</code>类中的方法添加到其他类中，我们可以扩展工具函数<code>augment</code>：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">augment</span><span class="params">(receivingClass, givingClass)</span> {</span>
  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">2</span>]) { <span class="comment">// 可接受三个参数，第三个参数为需添加的方法，多个方法可用数组将方法名传入</span>
    <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">2</span>] instanceOf <span class="built_in">Array</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>[<span class="number">2</span>].length; i &lt; len; i++) {
        <span class="keyword">if</span> (!receivingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>][i]]) {
          receivingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>][i]] = givingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>][i]];
        }
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>[<span class="number">2</span>] === <span class="string">'string'</span>) {
      <span class="keyword">if</span> (!receivingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>]]) {
        receivingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>]] = givingClass.prototype[<span class="built_in">arguments</span>[<span class="number">2</span>]];
      }
    }
  } <span class="keyword">else</span> {
    <span class="keyword">for</span> (methodName <span class="keyword">in</span> givingClass.prototype) {
      <span class="keyword">if</span> (!receivingClass.prototype[methodName]) {
        receivingClass.prototype[methodName] = givingClass.prototype[methodName];
      }
    }
  }
}
</pre></td></tr></table></figure>

<p>这时我们如果要给其他类添加<code>Mixin</code>中的方法的话可以直接这样写：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>augment(MyBlog, Mixin);
</pre></td></tr></table></figure>

<h2 id="类式继承和原型式继承的对比">类式继承和原型式继承的对比</h2>
<p>类式继承存在的意义很大一部分是为了满足对JavaScript的特性还不熟悉的程序员，毕竟这种方法是强行为了模仿其他面向对象语言的特性而创造的。JavaScript的原型式特征在父类和子类之间建立了一种双向的联系，这是JS区别于其他语言的特点。<br>原型式继承发挥了JS的特性，所有的子类继承的方法会通过原型链逐级向父类查找，因此用于继承的方法在内存中只会保存一份，这样可以节约内存。只有在对子类的某个方法进行直接设置，将继承而来的方法覆盖的时候才会对新方法单独生成副本。</p>
<h2 id="封装对继承的影响">封装对继承的影响</h2>
<p>一个经过封装的类，它的公用方法和特权方法可以被继承下来，因为它们是添加在原型链上的，在作为构造函数的时候可以继承给子类。而私用方法相当于作为了闭包中的变量，与原型链无关，因此不会被继承。</p>
<p>父类中的特权方法可以访问父类中的私用属性，而特权方法会被子类继承，因此子类也可以通过继承的特权方法间接访问父类的私用属性。但子类中新添加的特权方法不能访问父类中的私用属性，因为缺少了到达父类内部的原型链<strong>“通道”</strong>。</p>
]]></content>
    <summary type="html"><![CDATA[<p>继承这个东西在JavaScript中尤其复杂，我掌握得也不好，找工作面试的时候在这个问题上栽过跟头。JavaScript的继承方式属于原型式继承，非常灵活。因此JavaScript的继承方式除了基于类的继承之外还有基于原型的原型式继承。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(二)——封装，简单的创建对象模式]]></title>
    <link href="http://classicemi.github.io/2014/04/22/javascript-pattern-02/"/>
    <id>http://classicemi.github.io/2014/04/22/javascript-pattern-02/</id>
    <published>2014-04-22T05:51:28.000Z</published>
    <updated>2014-05-02T09:15:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="什么是封装">什么是封装</h2>
<p>找工作时一些公司给了offer后我就想知道真正拿到手的是多少，毕竟赋税繁重。但各种税也好，五险一金也好我实在是弄不清楚，于是我就会在网上的一些税后收入计算器上进行计算，只需要填写一些基本信息，比如税前收入，所在地区等等，就能够获得详细的结果，包括各种税收的详细数值。在这个过程中，我只是按照接口给定的要求进行了数据的输入，具体计算过程我并不知道。也就是说，在这个程序内部，数据表现形式和实现细节是隐藏的，这在某种意义上也是封装的一种。</p>
<a id="more"></a>

<p>在JavaScript中，对象中的细节有时也需要隐藏，但JS不像其他的静态语言，比如Java，一样，有<code>private</code>这样的关键字。那么在JavaScript中，就可以用闭包的概念来创建只能从对象内部访问的方法和属性。</p>
<p>在使用接口实现信息隐藏的过程中，同时也是使用了接口的概念。好比火影里的通灵术，人与动物签订契约，进行某种交换。这中间的沟通渠道不变，签订契约的人就可以随时随地进行通灵。一个类中，应该定义足够的安全的接口。然而在JS中，语言特性非常灵活，类中的公有方法和私有方法实际是一样的。因此，在实现类的时候，应该避免公开未定义于接口的方法。</p>
<h2 id="创建对象">创建对象</h2>
<p>JavaScript中，创建对象的基本模式有三种。</p>
<ul>
<li><strong> 直接创建 </strong>对象中的所有方法都是公有的，可以公开访问。</li>
<li><strong> 使用下划线 </strong>在私有方法名称前加下划线，表示该方法私有。</li>
<li><strong> 使用闭包 </strong>闭包可以创建真正意义上的私有成员，这些成员只能通过特定方法访问。</li>
</ul>
<h3 id="直接创建">直接创建</h3>
<p>所谓直接创建，就是按照传统的方式创建一个类，构造器是一个函数，属性和方法全部公开，比如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="keyword">var</span> Fruit = <span class="function"><span class="keyword">function</span><span class="params">(color, weight)</span> {</span>
  <span class="keyword">this</span>.color = color || <span class="string">'orange'</span>;
  <span class="keyword">this</span>.weight = weight || <span class="number">150</span>;
}

Fruit.prototype.boom = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  ...  
}
</pre></td></tr></table></figure>

<p>这种方法一般来说没什么问题，但是当其原型上的方法<code>boom</code>对自身的属性<code>color</code>或者<code>weight</code>有一定依赖，而构造时传入的参数不符合一定要求时就会出错。但如果构造时没有出错则所有方法应该能正常工作才是。</p>
<p>当然这个问题可以在构造对象时就对传入的参数进行验证，也不算太严重。然而另一个问题在于，即使能对参数进行验证，任何程序员还是能够随意修改属性的值。为了解决这个问题，可以设计一个数据的取值器和赋值器。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> Fruit = <span class="function"><span class="keyword">function</span><span class="params">(color, weight)</span> {</span>
  <span class="keyword">this</span>.setColor(color);
  <span class="keyword">this</span>.setWeight(weight);
}

Fruit.prototype = {
  checkColor: <span class="function"><span class="keyword">function</span><span class="params">(color)</span> {</span>
    ...
  },
  setColor: <span class="function"><span class="keyword">function</span><span class="params">(color)</span> {</span>
    ...
    <span class="keyword">this</span>.color = color;
  },
  getColor: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.color;
  },
  ...
}
</pre></td></tr></table></figure>

<p>当程序员之间约定以提供的方法对属性值进行操作时，操作过程可以相对得到规范。但实际上属性仍然是公开的，可以被直接设置，这种方法并不能阻止这种行为。</p>
<h3 id="使用下划线，区别私用成员">使用下划线，区别私用成员</h3>
<p>此种方法与前一种方法其实是一回事，只是在私用的方法和属性前加了下划线表示它是私用的。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> Fruit = <span class="function"><span class="keyword">function</span><span class="params">(color, weight)</span> {</span>
  <span class="keyword">this</span>.setColor(color);
  <span class="keyword">this</span>.setWeight(weight);
}

Fruit.prototype = {
  _checkColor: <span class="function"><span class="keyword">function</span><span class="params">(color)</span> {</span>
    ...
  },
  setColor: <span class="function"><span class="keyword">function</span><span class="params">(color)</span> {</span>
    ... <span class="comment">// 此处对输入的数据进行验证，不能通过验证就抛出异常</span>
    <span class="keyword">this</span>._color = color;
  },
  getColor: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>._color;
  },
  ...
}
</pre></td></tr></table></figure>

<p>这种方法有助于防止对私用方法的无意使用，但无法保证程序员不有意使用它们。</p>
<h3 id="使用闭包">使用闭包</h3>
<p>借助闭包就可以创建只允许特定函数访问的变量了，私用属性的创建方法即是在构造函数的作用域中创建变量即可，这些变量可以被该作用域中的所有函数访问。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="keyword">var</span> Fruit = <span class="function"><span class="keyword">function</span><span class="params">(newColor, weight)</span> {</span>
  <span class="keyword">var</span> color, weight;

  <span class="comment">// 私用方法</span>
  <span class="function"><span class="keyword">function</span> <span class="title">_checkColor</span> = <span class="title">function</span><span class="params">(color)</span> {</span>
    ...
  }

  <span class="comment">// 特权方法</span>
  <span class="keyword">this</span>.getColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> color;
  };

  <span class="keyword">this</span>.setColor = <span class="function"><span class="keyword">function</span><span class="params">(newColor)</span> {</span>
    ... <span class="comment">// 验证输入</span>
    color = newColor;
  }

  <span class="comment">// 构造过程代码</span>
  <span class="keyword">this</span>.setColor(newColor);
}
</pre></td></tr></table></figure>

<p>借助<code>this</code>关键字创建的方法就是特权方法了，它们是公开方法，同时也能够访问私有变量。如果需要创建一些不需要访问私有属性的方法的话，可以在<code>Fruit.prototype</code>上进行创建。通过这种方式创建的方法，不能直接访问私有变量，但是可以通过<code>getColor</code>这样的特权方法进行间接访问。</p>
<p>当然这种方式也有弊端，如果特权方法过多，会占用较多内存，因为通过构造函数创建的实例都保存了特权方法的副本，而原型上的方法只有一份。因此，在设计构造函数时，需要进行慎重考虑。</p>
<p>另一个问题就在于这样的方法无法作用于需要创建子类的场景，由于特权方法都是新的副本，所以子类无法访问超类的任何私用属性或方法。因此在JavaScript中，这种问题被称作“继承破坏封装”(inheritance breaks encapsulation)。</p>
<h2 id="高级创建对象模式初探">高级创建对象模式初探</h2>
<p>以上的三种方法属于创造对象的基本方法，但要实现一些高级的创建对象模式，有必要先了解一些概念。</p>
<h3 id="静态方法和属性">静态方法和属性</h3>
<p>前述的闭包创建对象法可以创建私用属性和方法，但是这样的话，这些属性在创建子类时会同时创建副本存于子类，造成内存的浪费。对于一些只需要在类层面进行操作和访问的属性，可以利用闭包创建静态成员。静态成员每个只有一份，直接通过类对象进行访问。</p>
<p>仍然以之前的<code>Orange</code>类为例，使用闭包特性添加一些静态成员：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="keyword">var</span> Orange = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// 私用静态属性</span>
  <span class="keyword">var</span> numOfOranges = <span class="number">0</span>;

  <span class="comment">// 私用静态方法</span>
  <span class="function"><span class="keyword">function</span> <span class="title">checkColor</span><span class="params">()</span> {</span>
    ...
  }

  <span class="comment">// 返回构造器</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(newColor, weight)</span> {</span>
    <span class="keyword">var</span> color, weight;

    <span class="comment">// 特权方法</span>
    <span class="keyword">this</span>.getColor = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> color;
    };
    <span class="keyword">this</span>.setColor = <span class="function"><span class="keyword">function</span><span class="params">(newColor)</span> {</span>
      ...
      color = newColor;
    }

    <span class="comment">// 构造器代码</span>
    numOfOrange++;
    <span class="keyword">if</span> (numOfOrange &gt; <span class="number">100</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Only 100 instances of Orange can be created.'</span>);
    }

    <span class="keyword">this</span>.setColor(newColor);
  }
})();

<span class="comment">// 公开静态方法</span>
Orange.turnToJuice = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="comment">// 不添加在Orange的prototype上</span>
  ...
};

<span class="comment">// 公开的非特权方法</span>
Orange.prototype = {
  checkWeight: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    ...
  }
};
</pre></td></tr></table></figure>

<p>这与之前的闭包创建类的最大区别在于构造器由一个普通函数变成了一个内嵌函数，通过一个自执行函数的返回值赋给<code>Orange</code>。在实例化<code>Orange</code>时，调用的是返回的内嵌函数，外层函数只是一个用来存放静态私用成员的闭包。在构造器中的特权方法可以访问构造器之外的静态属性和方法，而静态方法不能访问任何定义在构造器中的私用属性。</p>
<h3 id="常量">常量</h3>
<p>常量就是不能被修改的变量，利用静态属性可以在JavaScript中模拟常量。对常量只创建作为取值器的静态方法，而不创建赋值器，在外围作用域中也不能访问到常量：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="keyword">var</span> Class = (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="comment">// 常量</span>
  <span class="keyword">var</span> CONST = <span class="number">100</span>;

  <span class="comment">// 构造器</span>
  <span class="keyword">var</span> constructorFunc = <span class="function"><span class="keyword">function</span><span class="params">(param)</span> {</span>
    ...
  };

  <span class="comment">// 静态方法，取值器</span>
  constructorFunc = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> CONST;
  };

  <span class="keyword">return</span> constructorFunc;
})();
</pre></td></tr></table></figure>

<h2 id="封装之利弊">封装之利弊</h2>
<h3 id="封装之利">封装之利</h3>
<p>保护内部数据，只对外提供取值器和赋值器，便于重构。减少模块间耦合。</p>
<h3 id="封装之弊">封装之弊</h3>
<p>难以进行单元测试，外部测试无法访问到内部变量和方法。不过如公用方法可以间接访问私用方法的话，可以对私用方法进行间接单元测试。</p>
<p>实现过程较为复杂，调试难度比较大。</p>
]]></content>
    <summary type="html"><![CDATA[<h2 id="什么是封装">什么是封装</h2>
<p>找工作时一些公司给了offer后我就想知道真正拿到手的是多少，毕竟赋税繁重。但各种税也好，五险一金也好我实在是弄不清楚，于是我就会在网上的一些税后收入计算器上进行计算，只需要填写一些基本信息，比如税前收入，所在地区等等，就能够获得详细的结果，包括各种税收的详细数值。在这个过程中，我只是按照接口给定的要求进行了数据的输入，具体计算过程我并不知道。也就是说，在这个程序内部，数据表现形式和实现细节是隐藏的，这在某种意义上也是封装的一种。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 设计模式读书笔记(一)——接口]]></title>
    <link href="http://classicemi.github.io/2014/04/20/javascript-pattern-01/"/>
    <id>http://classicemi.github.io/2014/04/20/javascript-pattern-01/</id>
    <published>2014-04-20T13:31:28.000Z</published>
    <updated>2014-05-02T09:15:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JavaScript_中模仿接口的三种方法">JavaScript 中模仿接口的三种方法</h2>
<h3 id="1-_注释描述">1. 注释描述</h3>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">/*

interface Composite {
  function add(child);
  function remove(child);
  function getChild(index);
}

interface FormItem {
  function save();
}

 */</span>

<span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span><span class="params">(id, method, action)</span> {</span> <span class="comment">// 定义接口类</span>
  ...
};

<span class="comment">// 为接口类添加方法</span>
CompositeForm.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(child)</span> {</span>
  ...
};
CompositeForm.prototype.remove = <span class="function"><span class="keyword">function</span><span class="params">(child)</span> {</span>
  ...
};
CompositeForm.prototype.getChild = <span class="function"><span class="keyword">function</span><span class="params">(index)</span> {</span>
  ...
};

CompositeForm.prototype.save = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  ...
};
</pre></td></tr></table></figure>

<p>此种方法不易规范遵守，属于程序文档范畴，对接口的约定遵守全靠自觉。但是易于实现，不需额外的类或函数。</p>
<a id="more"></a>

<h3 id="2-_属性检查">2. 属性检查</h3>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="comment">/*

interface Composite {
  function add(child);
  function remove(child);
  function getChild(index);
}

interface FormItem {
  function save();
}

 */</span>

<span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span><span class="params">(id, method, action)</span> {</span>
  <span class="keyword">this</span>.implementsInterfaces = [<span class="string">'Composite'</span>, <span class="string">'FormItem'</span>];
  ...
};

...

<span class="function"><span class="keyword">function</span> <span class="title">addForm</span><span class="params">(formInstance)</span> {</span>
  <span class="keyword">if</span> (!implements(formInstance, <span class="string">'Composite'</span>, <span class="string">'FormItem'</span>)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Object does not implement a required interface."</span>);
  }
  ...
}

<span class="comment">// 检查一个对象是否实现了需要的接口</span>
<span class="function"><span class="keyword">function</span> <span class="title">implements</span><span class="params">(object)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) {
    <span class="keyword">var</span> interfaceName = <span class="built_in">arguments</span>[i];
    <span class="keyword">var</span> interfaceFound = <span class="literal">false</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; object.implementsInterfaces.length; j++) {
      <span class="keyword">if</span> (object.implementsInterfaces[j] == interfaceName) {
        interfaceFound = <span class="literal">true</span>;
        <span class="keyword">break</span>;
      }
    }
    <span class="keyword">if</span> (!interfaceFound) {
      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 未找到接口</span>
    }
  }
  <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 所有接口都找到了</span>
}
</pre></td></tr></table></figure>

<p>此方法的优点是对类实现的接口提供了文档说明，如果需要的接口未实现则会报错。缺点在于不能保证类是否真正实现了接口，只知道它是否说自己实现了接口，即使代码未将接口实现也能通过检查，这将在代码中留下隐患。</p>
<h3 id="3-_鸭式辨型">3. 鸭式辨型</h3>
<p>鸭式辨型的意思就是，如果对象具有与接口定义的方法同名的所有方法，那么就认为它实现了这个接口。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">// Interfaces</span>

<span class="keyword">var</span> Composite = <span class="keyword">new</span> Interface(<span class="string">'Composite'</span>, [<span class="string">'add'</span>, <span class="string">'remove'</span>, <span class="string">'getChild'</span>]);
<span class="keyword">var</span> FormItem = <span class="keyword">new</span> Interface(<span class="string">'FormItem'</span>, [<span class="string">'save'</span>]);

<span class="comment">// CompositeForm class</span>

<span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span><span class="params">(id, method, action)</span> {</span>
  ...
};

...

<span class="function"><span class="keyword">function</span> <span class="title">addForm</span><span class="params">(formInstance)</span> {</span>
  <span class="comment">// 如果需要的方法未实现则报错</span>
  ensureImplements(formInstance, Composite, FormItem);
  ...
}
</pre></td></tr></table></figure>

<p><code>ensureImplements</code>函数至少接受两个参数，一个是需要检查的对象，其余为针对此对象需要检查是否实现的接口。具体检查方式则是检查对象是否实现了接口所声明的所有方法。</p>
<p>此方法的缺点是缺乏其他两种方法的自我描述性，需要一个辅助类<code>Interface</code>和一个辅助函数<code>ensureImplements</code>。并且它只关心方法名称而不检查参数名称、数目、类型等。</p>
<h2 id="Interface类"><code>Interface</code>类</h2>
<p>综合第一及第三种接口实现方式，<code>Interface</code>类的定义可以为：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="code"><pre><span class="comment">// Constructor</span>

<span class="keyword">var</span> Interface = <span class="function"><span class="keyword">function</span><span class="params">(name, methods)</span> {</span>
  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length != <span class="number">2</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Interface constructor called with "</span> + <span class="built_in">arguments</span>.length +
      <span class="string">" arguments, but expected exactly 2."</span>);
  }

  <span class="keyword">this</span>.name = name;
  <span class="keyword">this</span>.methods = [];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = methods.length; i &lt; len; i++) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[i] !== <span class="string">'string'</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Interface constructor expects method names to be "</span> +
        <span class="string">" passed in as a string"</span>);
    }
    <span class="keyword">this</span>.methods.push(methods[i]);
  }
};

<span class="comment">// Static class method</span>

Interface.ensureImplements = <span class="function"><span class="keyword">function</span><span class="params">(object)</span> {</span>
  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; <span class="number">2</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function Interface.ensureImplements called with "</span> +
      <span class="built_in">arguments</span>.length + <span class="string">" arguments, but expected at least 2."</span>);
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) {
    <span class="keyword">var</span> interface = <span class="built_in">arguments</span>[i];
    <span class="keyword">if</span> (interface.constructor !== Interface) {
      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function Interface.ensureImplements expects arguments"</span> +
        <span class="string">"two and above to be instances of Interface."</span>);
    }

    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, methodsLen = interface.methods.length; j &lt; methodsLen; j++) {
      <span class="keyword">var</span> methods = interface.methods[j];
      <span class="keyword">if</span> (!object[method] || <span class="keyword">typeof</span> object[method] !== <span class="string">'function'</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Function Interface.ensureImplements: object "</span> +
          <span class="string">"does not implement the "</span> + interface.name +
          <span class="string">" interface. Method "</span> + method + <span class="string">" was not found."</span>);
      }
    }
  }
};
</pre></td></tr></table></figure>

<h2 id="依赖接口的设计模式">依赖接口的设计模式</h2>
<p>以下的设计模式依赖接口</p>
<ol>
<li><strong> 工厂模式 </strong>保证生产出来的对象实现了必须的方法。</li>
<li><strong> 组合模式 </strong>将对象群体与组成对象同等对待。</li>
<li><strong> 装饰者模式 </strong>透明地为另一对象提供包装，实现相同的接口。</li>
<li><strong> 命令模式 </strong>所有的命令对象都实现了同一批方法。</li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<h2 id="JavaScript_中模仿接口的三种方法">JavaScript 中模仿接口的三种方法</h2>
<h3 id="1-_注释描述">1. 注释描述</h3>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="comment">/*

interface Composite {
  function add(child);
  function remove(child);
  function getChild(index);
}

interface FormItem {
  function save();
}

 */</span>

<span class="keyword">var</span> CompositeForm = <span class="function"><span class="keyword">function</span><span class="params">(id, method, action)</span> {</span> <span class="comment">// 定义接口类</span>
  ...
};

<span class="comment">// 为接口类添加方法</span>
CompositeForm.prototype.add = <span class="function"><span class="keyword">function</span><span class="params">(child)</span> {</span>
  ...
};
CompositeForm.prototype.remove = <span class="function"><span class="keyword">function</span><span class="params">(child)</span> {</span>
  ...
};
CompositeForm.prototype.getChild = <span class="function"><span class="keyword">function</span><span class="params">(index)</span> {</span>
  ...
};

CompositeForm.prototype.save = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  ...
};
</pre></td></tr></table></figure>

<p>此种方法不易规范遵守，属于程序文档范畴，对接口的约定遵守全靠自觉。但是易于实现，不需额外的类或函数。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
      <category term="学习笔记" scheme="http://classicemi.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="设计模式" scheme="http://classicemi.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你真的了解 console 吗]]></title>
    <link href="http://classicemi.github.io/2014/04/14/console/"/>
    <id>http://classicemi.github.io/2014/04/14/console/</id>
    <published>2014-04-14T05:51:28.000Z</published>
    <updated>2014-05-02T09:15:58.000Z</updated>
    <content type="html"><![CDATA[<p>对于前端开发者来说，在开发过程中需要监控某些表达式或变量的值的时候，用 debugger 会显得过于笨重，取而代之则是会将值输出到控制台上方便调试。最常用的语句就是<code>console.log(expression)</code>了。</p>
<p>然而对于作为一个全局对象的<code>console</code>对象来说，大多数人了解得还并不全面，当然我也是，经过我的一番学习，现在对于这个能玩转控制台的 JS 对象有了一定的认识，想与大家分享一下。</p>
<p>console 对象除了<code>console.log()</code>这一最常被开发者使用的方法之外，还有很多其他的方法。灵活运用这些方法，可以给开发过程增添许多便利。</p>
<a id="more"></a>

<h2 id="console_的方法">console 的方法</h2>
<p><strong>console.assert(expression, object[, object…])</strong></p>
<p>接收至少两个参数，第一个参数的值或返回值为<code>false</code>的时候，将会在控制台上输出后续参数的值。例如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>console.assert(<span class="number">1</span> == <span class="number">1</span>, object); <span class="comment">// 无输出，返回 undefined</span>
console.assert(<span class="number">1</span> == <span class="number">2</span>, object); <span class="comment">// 输出 object</span>
</pre></td></tr></table></figure>

<p><strong>console.count([label])</strong></p>
<p>输出执行到该行的次数，可选参数 label 可以输出在次数之前，例如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
    console.count(<span class="string">'count'</span>);
  }
})();
<span class="comment">// count: 1</span>
<span class="comment">// count: 2</span>
<span class="comment">// count: 3</span>
<span class="comment">// count: 4</span>
<span class="comment">// count: 5</span>
</pre></td></tr></table></figure>

<p><strong>console.dir(object)</strong></p>
<p>将传入对象的属性，包括子对象的属性以列表形式输出，例如：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> obj = {
  name: <span class="string">'classicemi'</span>,
  college: <span class="string">'HUST'</span>,
  major: <span class="string">'ei'</span>
};
console.dir(obj);
</pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/img/console.dir.jpg" alt=""></p>
<p><strong>console.error(object[, object…])</strong></p>
<p>用于输出错误信息，用法和常见的<code>console.log</code>一样，不同点在于输出内容会标记为错误的样式，便于分辨。输出结果：</p>
<p><img src="/img/console.error.jpg" alt=""></p>
<p><strong>console.group</strong></p>
<p>这是个有趣的方法，它能够让控制台输出的语句产生不同的层级嵌套关系，每一个<code>console.group()</code>会增加一层嵌套，相反要减少一层嵌套可以使用<code>console.groupEnd()</code>方法。语言表述比较无力，看代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>console.log(<span class="string">'这是第一层'</span>);
console.group();
console.log(<span class="string">'这是第二层'</span>);
console.log(<span class="string">'依然第二层'</span>);
console.group();
console.log(<span class="string">'第三层了'</span>);
console.groupEnd();
console.log(<span class="string">'回到第二层'</span>);
console.groupEnd();
console.log(<span class="string">'回到第一层'</span>);
</pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/img/console.group.jpg" alt=""></p>
<p>和<code>console.group()</code>相似的方法是<code>console.groupCollapsed()</code>作用相同，不同点是嵌套的输出内容是折叠状态，在有大段内容输出的时候使用这个方法可以使输出版面不至于太长。。。吧</p>
<p><strong>console.info(object[, object…])</strong></p>
<p>此方法与之前说到的<code>console.error</code>一样，用于输出信息，没有什么特别之处。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.info(<span class="string">'info'</span>); <span class="comment">// 输出 info</span>
</pre></td></tr></table></figure>

<p><strong>console.table()</strong></p>
<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="keyword">var</span> obj = {
  foo: {
    name: <span class="string">'foo'</span>,
    age: <span class="string">'33'</span>
  },
  bar: {
    name: <span class="string">'bar'</span>,
    age: <span class="string">'45'</span>
  }
};

<span class="keyword">var</span> arr = [
  [<span class="string">'foo'</span>, <span class="string">'33'</span>],
  [<span class="string">'bar'</span>, <span class="string">'45'</span>]
];

console.table(obj);
console.table(arr);
</pre></td></tr></table></figure>

<p><img src="/img/console.table.jpg" alt=""></p>
<p>也可以</p>
<p><strong>console.log(object[, object…])</strong></p>
<p>这个不用多说，这个应该是开发者最常用的吧，也不知道是谁规定的。。。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.log(<span class="string">'log'</span>); <span class="comment">// 输出 log</span>
</pre></td></tr></table></figure>

<p><strong>console.profile([profileLabel])</strong></p>
<p>这是个挺高大上的东西，可用于性能分析。在 JS 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及<code>console.profile()</code>方法我们可以很方便地监控运行性能。</p>
<p>例如下面这段代码：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">parent</span><span class="params">()</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {
    childA()
  }
}

<span class="function"><span class="keyword">function</span> <span class="title">childA</span><span class="params">(j)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; j; i++) {}
}

console.profile(<span class="string">'性能分析'</span>);
parent();
console.profileEnd();
</pre></td></tr></table></figure>

<p>然后我们可以在 Profiles 面板下看到上述代码运行过程中的消耗时间。</p>
<p><img src="/img/console.profile1.jpg" alt=""></p>
<p>页面加载过程的性能优化是前端开发的一个重要部分，使用控制台的 profiles 面板可以监控所有 JS 的运行情况使用方法就像录像机一样，控制台会把运行过程录制下来。如图，工具栏上有录制和停止按钮。</p>
<p><img src="/img/console.profile3.jpg" alt=""></p>
<p>录制结果：</p>
<p><img src="/img/console.profile2.jpg" alt=""></p>
<p><strong>console.time(name)</strong><br>计时器，可以将成对的<code>console.time()</code>和<code>console.timeEnd()</code>之间代码的运行时间输出到控制台上，<code>name</code>参数可作为标签名。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>console.time(<span class="string">'计时器'</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) {
  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) {}
}
console.timeEnd(<span class="string">'计时器'</span>);
</pre></td></tr></table></figure>

<p><img src="/img/console.time.jpg" alt=""></p>
<p>（刚才实际多写了一层循环，结果电脑风扇呜呜转啊，浏览器直接无响应了。。。）</p>
<p><strong>console.trace()</strong></p>
<p><code>console.trace()</code>用来追踪函数的调用过程。在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">tracer</span><span class="params">(a)</span> {</span>
  console.trace();
  <span class="keyword">return</span> a;
}

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(a)</span> {</span>
  <span class="keyword">return</span> bar(a);
}

<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(a)</span> {</span>
  <span class="keyword">return</span> tracer(a);
}

<span class="keyword">var</span> a = foo(<span class="string">'tracer'</span>);
</pre></td></tr></table></figure>

<p>输出：</p>
<p><img src="/img/console.trace.jpg" alt=""></p>
<p><strong>console.warn(object[, object…])</strong></p>
<p>输出参数的内容，作为警告提示。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.warn(<span class="string">'warn'</span>); <span class="comment">// 输出 warn</span>
</pre></td></tr></table></figure>

<p><strong>占位符</strong></p>
<p><code>console</code>对象上的五个直接输出方法，<code>console.log()</code>,<code>console.warn()</code>,<code>console.error()</code>,<code>console.exception()</code>(等同于<code>console.error()</code>)和<code>console.info()</code>，都可以使用占位符。支持的占位符有四种，分别是字符(<code>%s</code>)、整数(<code>%d</code> 或 <code>%i</code>)、浮点数(<code>%f</code>)和对象(<code>%o</code>)。</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>console.log(<span class="string">'%s是%d年%d月%d日'</span>, <span class="string">'今天'</span>, <span class="number">2014</span>, <span class="number">4</span>, <span class="number">15</span>);
console.log(<span class="string">'圆周率是%f'</span>, <span class="number">3.14159</span>);

<span class="keyword">var</span> obj = {
  name: <span class="string">'classicemi'</span>
}
console.log(<span class="string">'%o'</span>, obj);
</pre></td></tr></table></figure>

<p><img src="/img/占位符.jpg" alt=""></p>
<p>还有一种特殊的标示符<code>%c</code>，对输出的文字可以附加特殊的样式，当进行大型项目开发的时候，代码中可能有很多其他开发者添加的控制台语句。开发者对自己的输出定制特别的样式就可以方便自己在眼花缭乱的输出结果中一眼看到自己需要的内容。想象力丰富的童鞋也可以做出有创意的输出信息，比如常见的招聘信息和个人介绍啥的。</p>
<p>输出结果：</p>
<figure class="highlight JavaScript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>console.log(<span class="string">'%cMy name is classicemi.'</span>, <span class="string">'color: #fff; background: #f40; font-size: 24px;'</span>);
</pre></td></tr></table></figure>

<p><img src="/img/c.jpg" alt=""></p>
<p><code>%c</code>标示符可以用各种 CSS 语句来为输出添加样式，再随便举个栗子，<code>background</code>属性的<code>url()</code>中添加图片路径就可以实现图片的输出了，各位前端童鞋快施展你们的 CSS 神技来把控制台玩坏吧~~</p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/console" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/console</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html" target="_blank">http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html</a></li>
<li><a href="http://blog.segmentfault.com/civerzhu/1190000000425386" target="_blank">http://blog.segmentfault.com/civerzhu/1190000000425386</a></li>
<li><a href="http://blog.mariusschulz.com/2013/11/13/advanced-JavaScript-debugging-with-consoletable" target="_blank">http://blog.mariusschulz.com/2013/11/13/advanced-JavaScript-debugging-with-consoletable</a></li>
</ol>
]]></content>
    <summary type="html"><![CDATA[<p>对于前端开发者来说，在开发过程中需要监控某些表达式或变量的值的时候，用 debugger 会显得过于笨重，取而代之则是会将值输出到控制台上方便调试。最常用的语句就是<code>console.log(expression)</code>了。</p>
<p>然而对于作为一个全局对象的<code>console</code>对象来说，大多数人了解得还并不全面，当然我也是，经过我的一番学习，现在对于这个能玩转控制台的 JS 对象有了一定的认识，想与大家分享一下。</p>
<p>console 对象除了<code>console.log()</code>这一最常被开发者使用的方法之外，还有很多其他的方法。灵活运用这些方法，可以给开发过程增添许多便利。</p>
]]></summary>
    
      <category term="前端" scheme="http://classicemi.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://classicemi.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
